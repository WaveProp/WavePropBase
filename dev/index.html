<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · WavePropBase.jl</title><link rel="canonical" href="https://WaveProp.github.io/WavePropBase.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WavePropBase.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaveProp/WavePropBase.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="WavePropBase"><a class="docs-heading-anchor" href="#WavePropBase">WavePropBase</a><a id="WavePropBase-1"></a><a class="docs-heading-anchor-permalink" href="#WavePropBase" title="Permalink"></a></h1><ul><li><a href="#WavePropBase.ENTITIES"><code>WavePropBase.ENTITIES</code></a></li><li><a href="#WavePropBase.TAGS"><code>WavePropBase.TAGS</code></a></li><li><a href="#WavePropBase.AbstractElement"><code>WavePropBase.AbstractElement</code></a></li><li><a href="#WavePropBase.AbstractEntity"><code>WavePropBase.AbstractEntity</code></a></li><li><a href="#WavePropBase.AbstractMesh"><code>WavePropBase.AbstractMesh</code></a></li><li><a href="#WavePropBase.CartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{HyperRectangle{N, T}, Tuple{Vararg{T, N}} where T}} where {N, T}"><code>WavePropBase.CartesianMesh</code></a></li><li><a href="#WavePropBase.CartesianMesh"><code>WavePropBase.CartesianMesh</code></a></li><li><a href="#WavePropBase.ComplexPoint2D"><code>WavePropBase.ComplexPoint2D</code></a></li><li><a href="#WavePropBase.ComplexPoint3D"><code>WavePropBase.ComplexPoint3D</code></a></li><li><a href="#WavePropBase.Domain"><code>WavePropBase.Domain</code></a></li><li><a href="#WavePropBase.ElementIterator"><code>WavePropBase.ElementIterator</code></a></li><li><a href="#WavePropBase.ElementaryEntity"><code>WavePropBase.ElementaryEntity</code></a></li><li><a href="#WavePropBase.ElementaryEntity-Tuple{Any, Any}"><code>WavePropBase.ElementaryEntity</code></a></li><li><a href="#WavePropBase.GenericMesh"><code>WavePropBase.GenericMesh</code></a></li><li><a href="#WavePropBase.HyperRectangle"><code>WavePropBase.HyperRectangle</code></a></li><li><a href="#WavePropBase.LagrangeElement"><code>WavePropBase.LagrangeElement</code></a></li><li><a href="#WavePropBase.LagrangeInterp"><code>WavePropBase.LagrangeInterp</code></a></li><li><a href="#WavePropBase.LagrangeLine"><code>WavePropBase.LagrangeLine</code></a></li><li><a href="#WavePropBase.LagrangeRectangle"><code>WavePropBase.LagrangeRectangle</code></a></li><li><a href="#WavePropBase.LagrangeTetrahedron"><code>WavePropBase.LagrangeTetrahedron</code></a></li><li><a href="#WavePropBase.LagrangeTriangle"><code>WavePropBase.LagrangeTriangle</code></a></li><li><a href="#WavePropBase.PlotPoints"><code>WavePropBase.PlotPoints</code></a></li><li><a href="#WavePropBase.Point1D"><code>WavePropBase.Point1D</code></a></li><li><a href="#WavePropBase.Point2D"><code>WavePropBase.Point2D</code></a></li><li><a href="#WavePropBase.Point3D"><code>WavePropBase.Point3D</code></a></li><li><a href="#WavePropBase.ReferenceLine"><code>WavePropBase.ReferenceLine</code></a></li><li><a href="#WavePropBase.ReferenceShape"><code>WavePropBase.ReferenceShape</code></a></li><li><a href="#WavePropBase.ReferenceSquare"><code>WavePropBase.ReferenceSquare</code></a></li><li><a href="#WavePropBase.ReferenceTetrahedron"><code>WavePropBase.ReferenceTetrahedron</code></a></li><li><a href="#WavePropBase.ReferenceTriangle"><code>WavePropBase.ReferenceTriangle</code></a></li><li><a href="#WavePropBase.SType"><code>WavePropBase.SType</code></a></li><li><a href="#WavePropBase.SubMesh"><code>WavePropBase.SubMesh</code></a></li><li><a href="#Base.:==-Tuple{AbstractEntity, AbstractEntity}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{Domain, Domain}"><code>Base.:==</code></a></li><li><a href="#Base.in-Tuple{ElementaryEntity, Domain}"><code>Base.in</code></a></li><li><a href="#Base.iterate"><code>Base.iterate</code></a></li><li><a href="#Base.keys-Tuple{Domain, Integer}"><code>Base.keys</code></a></li><li><a href="#Base.keys-Union{Tuple{T}, Tuple{Domain, Vector{T}}} where T&lt;:Integer"><code>Base.keys</code></a></li><li><a href="#Base.length-Tuple{Domain}"><code>Base.length</code></a></li><li><a href="#WavePropBase.abstractmethod-Tuple{DataType}"><code>WavePropBase.abstractmethod</code></a></li><li><a href="#WavePropBase.ambient_dimension"><code>WavePropBase.ambient_dimension</code></a></li><li><a href="#WavePropBase.assert_extension"><code>WavePropBase.assert_extension</code></a></li><li><a href="#WavePropBase.assertequaldim-Tuple{Domain, Domain}"><code>WavePropBase.assertequaldim</code></a></li><li><a href="#WavePropBase.blockmatrix_to_matrix-Union{Tuple{Matrix{B}}, Tuple{B}} where B&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})"><code>WavePropBase.blockmatrix_to_matrix</code></a></li><li><a href="#WavePropBase.blockvector_to_vector-Union{Tuple{Vector{B}}, Tuple{B}} where B&lt;:(StaticArrays.SVector{S, T} where {S, T})"><code>WavePropBase.blockvector_to_vector</code></a></li><li><a href="#WavePropBase.boundary"><code>WavePropBase.boundary</code></a></li><li><a href="#WavePropBase.bounding_box-Tuple{Vector{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:(StaticArrays.SVector{S, T} where {S, T})}"><code>WavePropBase.bounding_box</code></a></li><li><a href="#WavePropBase.center"><code>WavePropBase.center</code></a></li><li><a href="#WavePropBase.clear_entities!-Tuple{}"><code>WavePropBase.clear_entities!</code></a></li><li><a href="#WavePropBase.degree-Union{Tuple{Type{LagrangeLine{Np, T}}}, Tuple{T}, Tuple{Np}} where {Np, T}"><code>WavePropBase.degree</code></a></li><li><a href="#WavePropBase.diameter"><code>WavePropBase.diameter</code></a></li><li><a href="#WavePropBase.dom2elt-Tuple{WavePropBase.SubMesh}"><code>WavePropBase.dom2elt</code></a></li><li><a href="#WavePropBase.dom2elt-Tuple{GenericMesh, Any, DataType}"><code>WavePropBase.dom2elt</code></a></li><li><a href="#WavePropBase.dom2elt-Tuple{GenericMesh, Any}"><code>WavePropBase.dom2elt</code></a></li><li><a href="#WavePropBase.domain"><code>WavePropBase.domain</code></a></li><li><a href="#WavePropBase.enable_debug-Tuple{Any}"><code>WavePropBase.enable_debug</code></a></li><li><a href="#WavePropBase.entities-Tuple{Domain}"><code>WavePropBase.entities</code></a></li><li><a href="#WavePropBase.external_boundary-Tuple{Domain}"><code>WavePropBase.external_boundary</code></a></li><li><a href="#WavePropBase.geometric_dimension"><code>WavePropBase.geometric_dimension</code></a></li><li><a href="#WavePropBase.internal_boundary-Tuple{Domain}"><code>WavePropBase.internal_boundary</code></a></li><li><a href="#WavePropBase.jacobian"><code>WavePropBase.jacobian</code></a></li><li><a href="#WavePropBase.key-Tuple{AbstractEntity}"><code>WavePropBase.key</code></a></li><li><a href="#WavePropBase.matrix_to_blockmatrix-Tuple{Matrix{T} where T, Type{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})}"><code>WavePropBase.matrix_to_blockmatrix</code></a></li><li><a href="#WavePropBase.new_tag-Tuple{Any}"><code>WavePropBase.new_tag</code></a></li><li><a href="#WavePropBase.normal"><code>WavePropBase.normal</code></a></li><li><a href="#WavePropBase.notimplemented-Tuple{}"><code>WavePropBase.notimplemented</code></a></li><li><a href="#WavePropBase.print_threads_info-Tuple{}"><code>WavePropBase.print_threads_info</code></a></li><li><a href="#WavePropBase.radius"><code>WavePropBase.radius</code></a></li><li><a href="#WavePropBase.reference_nodes"><code>WavePropBase.reference_nodes</code></a></li><li><a href="#WavePropBase.return_type"><code>WavePropBase.return_type</code></a></li><li><a href="#WavePropBase.skeleton-Tuple{Domain}"><code>WavePropBase.skeleton</code></a></li><li><a href="#WavePropBase.sort_by_type-Tuple{Any}"><code>WavePropBase.sort_by_type</code></a></li><li><a href="#WavePropBase.svector-Tuple{Any, Any}"><code>WavePropBase.svector</code></a></li><li><a href="#WavePropBase.tag"><code>WavePropBase.tag</code></a></li><li><a href="#WavePropBase.vector_to_blockvector-Tuple{Vector{T} where T, Type{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(StaticArrays.SVector{S, T} where {S, T})}"><code>WavePropBase.vector_to_blockvector</code></a></li><li><a href="#WavePropBase.@interface"><code>WavePropBase.@interface</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ENTITIES" href="#WavePropBase.ENTITIES"><code>WavePropBase.ENTITIES</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">const ENTITIES</code></pre><p>Global dictionary storing the used entity tags (the value) for a given dimension (the key).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/entities.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.SType" href="#WavePropBase.SType"><code>WavePropBase.SType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const SType{T} = Union{T,Type{T}}</code></pre><p>Union type of <code>T</code> and its data type <code>Type{T}</code>. Used to simplify methods defined on singleton types where both <code>foo(::T)</code> and <code>foo(::Type{T})</code> are required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.TAGS" href="#WavePropBase.TAGS"><code>WavePropBase.TAGS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">const TAGS::Dict{Int,Vector{Int}}</code></pre><p>Global dictionary storing the used entity tags (the value) for a given dimension (the key).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/entities.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.AbstractElement" href="#WavePropBase.AbstractElement"><code>WavePropBase.AbstractElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractElement{D,T}</code></pre><p>Abstract element given by an interpolation scheme of <a href="#WavePropBase.return_type"><code>return_type</code></a> <code>T</code> over the domain <code>D&lt;:ReferenceShape</code>.</p><p>Instances <code>el</code> of <code>AbstractElement</code> are expected to implement:</p><ul><li><code>el(x̂)</code>: evaluate the interpolation scheme at the coordinate <code>x̂ ∈ D</code>.</li><li><code>jacobian(el,x̂)</code> : evaluate the jacobian matrix of the interpolation at the   coordinate <code>x ∈ D</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For performance reasons, both <code>el(x̂)</code> and <code>jacobian(el,x̂)</code> should typically operate on static arrays/vectors.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/element.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.AbstractEntity" href="#WavePropBase.AbstractEntity"><code>WavePropBase.AbstractEntity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractEntity</code></pre><p>Entity of geometrical nature. Identifiable throught its <code>(dim,tag)</code> key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/entities.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.AbstractMesh" href="#WavePropBase.AbstractMesh"><code>WavePropBase.AbstractMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractMesh{N,T}</code></pre><p>An abstract parent structure in dimension <code>N</code> with primite data of type <code>T</code> (e.g. <code>Float64</code> for double precision representation).</p><p>The <code>AbstractMesh</code> interface expects the following methods to be implemented:</p><ul><li><code>keys(msh)</code> : return a list of the element types composing the mesh.</li><li><code>msh[E]</code>    : return an <a href="#WavePropBase.ElementIterator"><code>ElementIterator</code></a> for the mesh elements of type <code>E</code></li></ul><p><strong>See also: <a href="#WavePropBase.ElementIterator"><code>ElementIterator</code></a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/abstractmesh.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.CartesianMesh" href="#WavePropBase.CartesianMesh"><code>WavePropBase.CartesianMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CartesianMesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>An <code>N</code>-dimensional cartesian grid given as the tensor-product of <code>N</code> one-dimensional <code>Vector{T}</code> grids.</p><p>Iterating over a <code>CartesianMesh</code> generates the elements which compose the mesh; i.e. the <code>HyperRectangle</code> cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/cartesianmesh.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.CartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{HyperRectangle{N, T}, Tuple{Vararg{T, N}} where T}} where {N, T}" href="#WavePropBase.CartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{HyperRectangle{N, T}, Tuple{Vararg{T, N}} where T}} where {N, T}"><code>WavePropBase.CartesianMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CartesianMesh(;domain::HyperRectangle,sz::NTuple)</code></pre><p>Construct a uniform <code>CartesianMesh</code> with <code>sz[d]</code> elements along dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/cartesianmesh.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ComplexPoint2D" href="#WavePropBase.ComplexPoint2D"><code>WavePropBase.ComplexPoint2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const ComplexPoint2D
const ComplexPoint2D(x1, x2)
const ComplexPoint2D(x::NTuple{2, ComplexF64})</code></pre><p>A complex 2D point, stored in a StaticArray. ComplexPoint2D = SVector{2, ComplexF64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L172-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ComplexPoint3D" href="#WavePropBase.ComplexPoint3D"><code>WavePropBase.ComplexPoint3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const ComplexPoint3D
const ComplexPoint3D(x1, x2, x3)
const ComplexPoint3D(x::NTuple{3, ComplexF64})</code></pre><p>A complex 3D point, stored in a StaticArray. ComplexPoint3D = SVector{3, ComplexF64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L162-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Domain" href="#WavePropBase.Domain"><code>WavePropBase.Domain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Domain</code></pre><p>Represent a physical domain as a union of entities.</p><p><strong>See also: <a href="#WavePropBase.AbstractEntity"><code>AbstractEntity</code></a>, <a href="#WavePropBase.ElementaryEntity"><code>ElementaryEntity</code></a>.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ElementIterator" href="#WavePropBase.ElementIterator"><code>WavePropBase.ElementIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ElementIterator{E,M}</code></pre><p>Return an iterator for all elements of type <code>E</code> on a mesh of type <code>M</code>.</p><p>Besides the methods listed in the <a href="https://docs.julialang.org/en/v1/manual/interfaces/">iterator iterface</a> of <code>Julia</code>, some functions also require the <code>getindex(iter,i::Int)</code> method for accessing the <code>i</code>-th element directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/abstractmesh.jl#L24-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ElementaryEntity" href="#WavePropBase.ElementaryEntity"><code>WavePropBase.ElementaryEntity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ElementaryEntity &lt;: AbstractEntity</code></pre><p>The most basic representation of an <a href="#WavePropBase.AbstractEntity"><code>AbstractEntity</code></a>.</p><p><strong>Fields:</strong></p><ul><li><code>dim::UInt8</code>: the geometrical dimension of the entity (e.g. line has <code>dim=1</code>, surface has <code>dim=2</code>, etc)</li><li><code>tag::Int64</code>: an integer tag associated to the entity</li><li><code>boundary::Vector{ElementaryEntity}</code>: the entities of dimension <code>dim-1</code> forming the entity&#39;s boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/entities.jl#L15-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ElementaryEntity-Tuple{Any, Any}" href="#WavePropBase.ElementaryEntity-Tuple{Any, Any}"><code>WavePropBase.ElementaryEntity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ElementaryEntity(dim,tag)</code></pre><p>Construct an <a href="#WavePropBase.ElementaryEntity"><code>ElementaryEntity</code></a> with an empty boundary .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/entities.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.GenericMesh" href="#WavePropBase.GenericMesh"><code>WavePropBase.GenericMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GenericMesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>Data structure representing a generic mesh in an ambient space of dimension <code>N</code>, with data of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/genericmesh.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.HyperRectangle" href="#WavePropBase.HyperRectangle"><code>WavePropBase.HyperRectangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HyperRectangle{N,T}</code></pre><p>Hyperrectangle in <code>N</code> dimensions described by a <code>low_corner::SVector{N,T}</code> and a <code>high_corner::SVector{N,T}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/hyperrectangle.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.LagrangeElement" href="#WavePropBase.LagrangeElement"><code>WavePropBase.LagrangeElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LagrangeElement{D,Np,T} &lt;: AbstractElement{D,T}</code></pre><p><strong>Fields:</strong></p><ul><li><code>vals::SVector{Np,T}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/element.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.LagrangeInterp" href="#WavePropBase.LagrangeInterp"><code>WavePropBase.LagrangeInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LagrangeInterp{N,Td,T}</code></pre><p>Generic Lagrange interpolation over an <code>N</code>-dimensional tensor grid. The implementation uses a multidimensional generalization of the barycentric formula.</p><p>The main constructor takes an <code>SVector{N,Vector{Td}}</code> containig the <code>N</code> one-dimensional <code>nodes</code> and an <code>Array{N,T}</code> of the function <code>vals</code> at the tensor product grid formed by the one-dimensional <code>nodes</code>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia">nx = 10
ny = 12
x   = [0.5+0.5cos((2k-1)*π/2nx) for k in 1:nx] # Chebyshev nodes
y   = [0.5+0.5cos((2k-1)*π/2ny) for k in 1:ny] # Chebyshev nodes
f   = (x) -&gt; cos(x[1]*x[2])
vals = [f((x,y)) for x in x, y in y]
p   = LagrangeInterp(SVector(x,y),vals)
p((0.1,0.2)) ≈ f((0.1,0.2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/lagrangeinterp.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.LagrangeLine" href="#WavePropBase.LagrangeLine"><code>WavePropBase.LagrangeLine</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const LagrangeLine = LagrangeElement{ReferenceLine}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/element.jl#L223-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.LagrangeRectangle" href="#WavePropBase.LagrangeRectangle"><code>WavePropBase.LagrangeRectangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const LagrangeRectangle = LagrangeElement{ReferenceSquare}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/element.jl#L238-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.LagrangeTetrahedron" href="#WavePropBase.LagrangeTetrahedron"><code>WavePropBase.LagrangeTetrahedron</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/element.jl#L233-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.LagrangeTriangle" href="#WavePropBase.LagrangeTriangle"><code>WavePropBase.LagrangeTriangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const LagrangeTriangle = LagrangeElement{ReferenceTriangle}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/element.jl#L228-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.PlotPoints" href="#WavePropBase.PlotPoints"><code>WavePropBase.PlotPoints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PlotPoints</code></pre><p>Structure used for dispatching plot recipes. Its use also avoids the problem of type-piracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/plotrecipes.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Point1D" href="#WavePropBase.Point1D"><code>WavePropBase.Point1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const Point1D
const Point1D(x1)</code></pre><p>A point in 1D space, stored in a StaticArray. Point1D = SVector{1, Float64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Point2D" href="#WavePropBase.Point2D"><code>WavePropBase.Point2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const Point2D
const Point2D(x1, x2)
const Point2D(x::NTuple{2, Float64})</code></pre><p>A point in 2D space, stored in a StaticArray. Point2D = SVector{2, Float64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L142-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Point3D" href="#WavePropBase.Point3D"><code>WavePropBase.Point3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const Point3D
const Point3D(x1, x2, x3)
const Point3D(x::NTuple{3, Float64})</code></pre><p>A point in 3D space, stored in a StaticArray. Point3D = SVector{3, Float64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L152-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ReferenceLine" href="#WavePropBase.ReferenceLine"><code>WavePropBase.ReferenceLine</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ReferenceLine</code></pre><p>Singleton type representing the <code>[0,1]</code> segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/referenceshapes.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ReferenceShape" href="#WavePropBase.ReferenceShape"><code>WavePropBase.ReferenceShape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ReferenceShape{N}</code></pre><p>Singleton types defining a referene domain/shape in <code>ℜᴺ</code>. Typically used to define more complex shapes as transformations mapping an <code>ReferenceShape</code> into some region of <code>ℜᴹ</code> through a given map.</p><p>See e.g. <a href="#WavePropBase.ReferenceLine"><code>ReferenceLine</code></a> or <a href="#WavePropBase.ReferenceTriangle"><code>ReferenceTriangle</code></a> for examples of concrete subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/referenceshapes.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ReferenceSquare" href="#WavePropBase.ReferenceSquare"><code>WavePropBase.ReferenceSquare</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ReferenceSquare</code></pre><p>Singleton type representing the square with vertices <code>(0,0),(0,1),(1,1),(1,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/referenceshapes.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ReferenceTetrahedron" href="#WavePropBase.ReferenceTetrahedron"><code>WavePropBase.ReferenceTetrahedron</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ReferenceTetrahedron</code></pre><p>Singleton type representing the tetrahedron with vertices <code>(0,0,0),(0,0,1),(0,1,0),(1,0,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/referenceshapes.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ReferenceTriangle" href="#WavePropBase.ReferenceTriangle"><code>WavePropBase.ReferenceTriangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ReferenceTriangle</code></pre><p>Singleton type representing the triangle with vertices <code>(0,0),(0,1),(1,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/referenceshapes.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.SubMesh" href="#WavePropBase.SubMesh"><code>WavePropBase.SubMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SubMesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>Create a view of a <code>parent</code> mesh over a given <code>domain</code>.</p><p>A submesh implements the interface for <code>AbstractMesh</code>; therefore you can iterate over elements of the submesh just like you would with a mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/submesh.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{AbstractEntity, AbstractEntity}" href="#Base.:==-Tuple{AbstractEntity, AbstractEntity}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(Ω1::AbstractEntity,Ω2::AbstractEntity)</code></pre><p>Two elementary entities are considered equal <code>geometric_dimension(Ω1)==geometric_dimension(Ω2)</code> and <code>abs(tag(Ω1))=abs(tag(Ω2))</code>. The sign of <code>tag(Ω)</code> is used to determine its orientation.</p><p>Notice that this implies <code>dim</code> and <code>tag</code> of an elementary entity should uniquely define it (up to the sign of <code>tag</code>), and therefore global variables like <a href="#WavePropBase.TAGS"><code>TAGS</code></a> are needed to make sure newly created <code>AbstractEntities</code> have a new <code>(dim,tag)</code> identifier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/entities.jl#L60-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Domain, Domain}" href="#Base.:==-Tuple{Domain, Domain}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">===(Ω1::Domain,Ω2::Domain)</code></pre><p>Two <code>Domain</code>s are equal if all their entities are equal (regardless of order).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{ElementaryEntity, Domain}" href="#Base.in-Tuple{ElementaryEntity, Domain}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">in(ω::ElementaryEntity,Ω::Domain)</code></pre><p>Check whether an <code>ElementaryEntity</code> belongs to a <code>Domain</code> by recursively checking whether it belongs to its boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iterate(Ω::Domain)</code></pre><p>Iterating over a domain means iterating over its entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{Domain, Integer}" href="#Base.keys-Tuple{Domain, Integer}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return all tags of the elementary entities in the domain <code>Ω</code> corresponding to the dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L149-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Union{Tuple{T}, Tuple{Domain, Vector{T}}} where T&lt;:Integer" href="#Base.keys-Union{Tuple{T}, Tuple{Domain, Vector{T}}} where T&lt;:Integer"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return all tags of the elementary entities in the domain <code>Ω</code> corresponding to the dimensions contained in <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L167-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{Domain}" href="#Base.length-Tuple{Domain}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(Ω:::Domain)</code></pre><p>The length of a domain corresponds to the number of elementary entities that make it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.abstractmethod-Tuple{DataType}" href="#WavePropBase.abstractmethod-Tuple{DataType}"><code>WavePropBase.abstractmethod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abstractmethod</code></pre><p>A method of an <code>abstract type</code> for which concrete subtypes are expected to provide an implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ambient_dimension" href="#WavePropBase.ambient_dimension"><code>WavePropBase.ambient_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ambient_dimension(x)</code></pre><p>Dimension of the ambient space where <code>x</code> lives. For geometrical objects this can differ from its <a href="#WavePropBase.geometric_dimension"><code>geometric_dimension</code></a>; for example a triangle in <code>ℝ³</code> has ambient dimension <code>3</code> but geometric dimension <code>2</code>, while a curve in <code>ℝ³</code> has ambient dimension 3 but geometric dimension 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.assert_extension" href="#WavePropBase.assert_extension"><code>WavePropBase.assert_extension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assert_extension(fname,ext,[msg])</code></pre><p>Check that <code>fname</code> is of extension <code>ext</code>. Print the message <code>msg</code> as an assertion error otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.assertequaldim-Tuple{Domain, Domain}" href="#WavePropBase.assertequaldim-Tuple{Domain, Domain}"><code>WavePropBase.assertequaldim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assertequaldim(Ω1::Domain,Ω2::Domain)</code></pre><p>Check that two domains have same dimension.</p><p>If one of the domain (or both) are empty, the assertion is assumed to be true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.blockmatrix_to_matrix-Union{Tuple{Matrix{B}}, Tuple{B}} where B&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})" href="#WavePropBase.blockmatrix_to_matrix-Union{Tuple{Matrix{B}}, Tuple{B}} where B&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})"><code>WavePropBase.blockmatrix_to_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blockmatrix_to_matrix(A::Matrix{B}) where {B&lt;:SMatrix}</code></pre><p>Convert a <code>Matrix{B}</code>, where <code>B&lt;:SMatrix</code>, to the equivalent <code>Matrix{T}</code>, where <code>T = eltype(B)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.blockvector_to_vector-Union{Tuple{Vector{B}}, Tuple{B}} where B&lt;:(StaticArrays.SVector{S, T} where {S, T})" href="#WavePropBase.blockvector_to_vector-Union{Tuple{Vector{B}}, Tuple{B}} where B&lt;:(StaticArrays.SVector{S, T} where {S, T})"><code>WavePropBase.blockvector_to_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blockvector_to_vector(A::Vector{B}) where {B&lt;:SVector}</code></pre><p>Convert a <code>Vector{B}</code>, where <code>B&lt;:SVector</code>, to the equivalent <code>Vector{T}</code>, where <code>T = eltype(B)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.boundary" href="#WavePropBase.boundary"><code>WavePropBase.boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">boundary(ω)</code></pre><p>Return the boundary of <code>ω</code>. For a mesh element gives the <code>d-1</code> dimensional elements composing its boundary, while for an entity gives the corresponding <code>d-1</code> dimensional entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.bounding_box-Tuple{Vector{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:(StaticArrays.SVector{S, T} where {S, T})}" href="#WavePropBase.bounding_box-Tuple{Vector{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:(StaticArrays.SVector{S, T} where {S, T})}"><code>WavePropBase.bounding_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bounding_box(data)</code></pre><p>Create a <a href="#WavePropBase.HyperRectangle"><code>HyperRectangle</code></a> to bound the points in <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/hyperrectangle.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.center" href="#WavePropBase.center"><code>WavePropBase.center</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">center(Ω)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.clear_entities!-Tuple{}" href="#WavePropBase.clear_entities!-Tuple{}"><code>WavePropBase.clear_entities!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_entities!()</code></pre><p>Empty the global variables used to keep track of the various entities created.</p><p><strong>See also: <a href="#WavePropBase.ENTITIES"><code>ENTITIES</code></a>, <a href="#WavePropBase.TAGS"><code>TAGS</code></a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/entities.jl#L160-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.degree-Union{Tuple{Type{LagrangeLine{Np, T}}}, Tuple{T}, Tuple{Np}} where {Np, T}" href="#WavePropBase.degree-Union{Tuple{Type{LagrangeLine{Np, T}}}, Tuple{T}, Tuple{Np}} where {Np, T}"><code>WavePropBase.degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degree(el::LagrangeElement)</code></pre><p>The degree of the underlying polynomial used to represent this type of element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/element.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.diameter" href="#WavePropBase.diameter"><code>WavePropBase.diameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diameter(Ω)</code></pre><p>Largest distance between <code>x</code> and <code>y</code> for <code>x,y ∈ Ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.dom2elt-Tuple{GenericMesh, Any, DataType}" href="#WavePropBase.dom2elt-Tuple{GenericMesh, Any, DataType}"><code>WavePropBase.dom2elt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dom2elt(m::GenericMesh,Ω,E)</code></pre><p>Compute the element indices <code>idxs</code> of the elements of type <code>E</code> composing <code>Ω</code>, so that <code>m[E][idxs]</code> gives all the elements of type <code>E</code> meshing <code>Ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/genericmesh.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.dom2elt-Tuple{GenericMesh, Any}" href="#WavePropBase.dom2elt-Tuple{GenericMesh, Any}"><code>WavePropBase.dom2elt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dom2elt(m::GenericMesh,Ω)</code></pre><p>Return a <code>Dict</code> with keys being the element types of <code>m</code>, and values being the indices of the elements in <code>Ω</code> of that type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/genericmesh.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.dom2elt-Tuple{WavePropBase.SubMesh}" href="#WavePropBase.dom2elt-Tuple{WavePropBase.SubMesh}"><code>WavePropBase.dom2elt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dom2elt(m::SubMesh,[E])</code></pre><p>A dictionary with keys being the element types of <code>m</code>, and values being the element indices in the parent mesh. If a type <code>E</code> is given, return the values associated with that key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/submesh.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.domain" href="#WavePropBase.domain"><code>WavePropBase.domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">domain(f)</code></pre><p>The domain of <code>f</code>. For elements of geometrical nature return the <code>ReferenceShape</code> used to represent it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.enable_debug-Tuple{Any}" href="#WavePropBase.enable_debug-Tuple{Any}"><code>WavePropBase.enable_debug</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">enable_debug(mname)</code></pre><p>Activate debugging messages by setting the environment variable <code>JULIA_DEBUG</code> to <code>mname</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.entities-Tuple{Domain}" href="#WavePropBase.entities-Tuple{Domain}"><code>WavePropBase.entities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">entities(Ω::Domain)</code></pre><p>Return a vector of all elementary entities making up a domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.external_boundary-Tuple{Domain}" href="#WavePropBase.external_boundary-Tuple{Domain}"><code>WavePropBase.external_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the external boundaries inside a domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.geometric_dimension" href="#WavePropBase.geometric_dimension"><code>WavePropBase.geometric_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">geometric_dimension(x)
geometric_dimension(Ω::Domain)</code></pre><p>Number of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in <code>ℝ²</code> or in <code>ℝ³</code>), while surfaces have geometric dimension of 2.</p><p>When the argument is a <code>Domain</code>, return the largest geometric dimension encoutered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.internal_boundary-Tuple{Domain}" href="#WavePropBase.internal_boundary-Tuple{Domain}"><code>WavePropBase.internal_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the internal boundaries inside a domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.jacobian" href="#WavePropBase.jacobian"><code>WavePropBase.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobian(F,x̂)</code></pre><p>The Jacobian matrix <code>Aᵢⱼ = ∂Fᵢ/∂x̂ⱼ</code> at the parametric coordinate <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.key-Tuple{AbstractEntity}" href="#WavePropBase.key-Tuple{AbstractEntity}"><code>WavePropBase.key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">key(e::AbstractEntity)</code></pre><p>The <code>(dim,tag)</code> pair used as a key to identify various abstract entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/entities.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.matrix_to_blockmatrix-Tuple{Matrix{T} where T, Type{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})}" href="#WavePropBase.matrix_to_blockmatrix-Tuple{Matrix{T} where T, Type{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})}"><code>WavePropBase.matrix_to_blockmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matrix_to_blockmatrix(A::Matrix,B)</code></pre><p>Convert a <code>Matrix{T}</code> to a <code>Matrix{B}</code>, where <code>B&lt;:Type{SMatrix}</code>. The element type of <code>B</code> must match that of <code>A</code>, and the size of <code>A</code> must be divisible by the size of <code>B</code> along each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.new_tag-Tuple{Any}" href="#WavePropBase.new_tag-Tuple{Any}"><code>WavePropBase.new_tag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">new_tag(dim)</code></pre><p>Generate a unique tag for an <code>AbstractEntity</code> of dimension <code>dim</code>.</p><p>The implementation consists of adding one to the maximum value of <code>TAGS[dim]</code></p><p><strong>See also: <a href="#WavePropBase.TAGS"><code>TAGS</code></a>.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/entities.jl#L114-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.normal" href="#WavePropBase.normal"><code>WavePropBase.normal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal(el,x̂)</code></pre><p>The unit normal vector of <code>el</code> at the parametric coordinate <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.notimplemented-Tuple{}" href="#WavePropBase.notimplemented-Tuple{}"><code>WavePropBase.notimplemented</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">notimplemented()</code></pre><p>Things which should probably be implemented at some point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.print_threads_info-Tuple{}" href="#WavePropBase.print_threads_info-Tuple{}"><code>WavePropBase.print_threads_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">print_threads_info()</code></pre><p>Prints in console the total number of threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.radius" href="#WavePropBase.radius"><code>WavePropBase.radius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">radius(Ω)</code></pre><p>Half the <a href="#WavePropBase.diameter"><code>diameter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.reference_nodes" href="#WavePropBase.reference_nodes"><code>WavePropBase.reference_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reference_nodes(::LagrangeElement{D,Np,T})</code></pre><p>Return the reference nodes on <code>D</code> used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.</p><p>We use the same convention as <code>gmsh</code> for defining the reference nodes and their order (see <a href="https://gmsh.info/doc/texinfo/gmsh.html#Node-ordering">node ordering</a> on <code>gmsh</code> documentation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/element.jl#L75-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.return_type" href="#WavePropBase.return_type"><code>WavePropBase.return_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">return_type(f)</code></pre><p>The type returned by the function-like object <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.skeleton-Tuple{Domain}" href="#WavePropBase.skeleton-Tuple{Domain}"><code>WavePropBase.skeleton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">skeleton(Ω::Domain)</code></pre><p>Return all the boundaries of the domain, i.e. the domain&#39;s skeleton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/domain.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.sort_by_type-Tuple{Any}" href="#WavePropBase.sort_by_type-Tuple{Any}"><code>WavePropBase.sort_by_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_by_type(v)</code></pre><p>Sort the elements of <code>v</code> into vectors <code>vi</code> according to their type. Return a <code>Dict{DataType,Vector}</code> mapping each type to a vector of that type.</p><p><strong>Examples</strong></p><pre><code class="language-julia">v = [1,&quot;a&quot;,3,&quot;b&quot;]
dict = sort_by_type(v)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L190-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.svector-Tuple{Any, Any}" href="#WavePropBase.svector-Tuple{Any, Any}"><code>WavePropBase.svector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">svector(f,n)</code></pre><p>Just like <a href="https://docs.julialang.org/en/v1/base/base/#Base.ntuple"><code>Base.ntuple</code></a>, but convert output to an <code>SVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.tag" href="#WavePropBase.tag"><code>WavePropBase.tag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tag(::AbstractEntity)</code></pre><p>Integer tag used to idetify geometrical entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/interface.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.vector_to_blockvector-Tuple{Vector{T} where T, Type{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(StaticArrays.SVector{S, T} where {S, T})}" href="#WavePropBase.vector_to_blockvector-Tuple{Vector{T} where T, Type{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(StaticArrays.SVector{S, T} where {S, T})}"><code>WavePropBase.vector_to_blockvector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_to_blockvector(A::Vector,B)</code></pre><p>Convert a <code>Vector{T}</code> to a <code>Vector{B}</code>, where <code>B&lt;:Type{SVector}</code>. The element type of <code>B</code> must match that of <code>A</code>, and the size of <code>A</code> must be divisible by the size of <code>B</code> along each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L61-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.@interface" href="#WavePropBase.@interface"><code>WavePropBase.@interface</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@interface f [n=1]</code></pre><p>Declare that the function <code>f</code> is an interface function. The call <code>f(args...)</code> resolves to <code>M.f(args...)</code> where <code>M</code> is parent module of the <code>args[n]</code> object.</p><p>The somewhat contrived example below illustrates how this can be used to have a generic method defined in module <code>A</code> applied to a type defined on module <code>B</code> which is independent of <code>A</code> but which implements the interface function <code>f</code>:</p><pre><code class="language-julia">module A
    using WavePropBase
    WavePropBase.@interface foo
    # a method which works on any type `x` implementing the `foo` function
    do_work(x) = 2*foo(x)
end

module B
    struct Foo end
    foo(x::Foo) = 1
end

using .A
using .B
foo = B.Foo()
A.do_work(foo)

# output

2</code></pre><p>Note that if in the example above module <code>A</code> implements a generic version of <code>foo</code>, the call <code>A.do_work(foo)</code> would use that method instead based on the dispatch rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/8d0463c1b7bc5316799f15c28bb1e9f443a22ab8/src/utils.jl#L214-L251">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 9 June 2021 19:30">Wednesday 9 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

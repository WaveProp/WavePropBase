var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = WavePropBase","category":"page"},{"location":"#WavePropBase","page":"Home","title":"WavePropBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase]","category":"page"},{"location":"#WavePropBase.ENTITIES","page":"Home","title":"WavePropBase.ENTITIES","text":"const ENTITIES\n\nGlobal dictionary storing the used entity tags (the value) for a given dimension (the key).\n\n\n\n\n\n","category":"constant"},{"location":"#WavePropBase.SType","page":"Home","title":"WavePropBase.SType","text":"const SType{T} = Union{T,Type{T}}\n\nUnion type of T and its data type Type{T}. Used to simplify methods defined on singleton types where both foo(::T) and foo(::Type{T}) are required.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.TAGS","page":"Home","title":"WavePropBase.TAGS","text":"const TAGS::Dict{Int,Vector{Int}}\n\nGlobal dictionary storing the used entity tags (the value) for a given dimension (the key).\n\n\n\n\n\n","category":"constant"},{"location":"#WavePropBase.AbstractEntity","page":"Home","title":"WavePropBase.AbstractEntity","text":"abstract type AbstractEntity\n\nEntity of geometrical nature. Identifiable throught its (dim,tag) key.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ComplexPoint2D","page":"Home","title":"WavePropBase.ComplexPoint2D","text":"const ComplexPoint2D\nconst ComplexPoint2D(x1, x2)\nconst ComplexPoint2D(x::NTuple{2, ComplexF64})\n\nA complex 2D point, stored in a StaticArray. ComplexPoint2D = SVector{2, ComplexF64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ComplexPoint3D","page":"Home","title":"WavePropBase.ComplexPoint3D","text":"const ComplexPoint3D\nconst ComplexPoint3D(x1, x2, x3)\nconst ComplexPoint3D(x::NTuple{3, ComplexF64})\n\nA complex 3D point, stored in a StaticArray. ComplexPoint3D = SVector{3, ComplexF64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ElementaryEntity","page":"Home","title":"WavePropBase.ElementaryEntity","text":"struct ElementaryEntity <: AbstractEntity\n\nThe most basic representation of an AbstractEntity.\n\nFields:\n\ndim::UInt8: the geometrical dimension of the entity (e.g. line has dim=1, surface has dim=2, etc)\ntag::Int64: an integer tag associated to the entity\nboundary::Vector{ElementaryEntity}: the entities of dimension dim-1 forming the entity's boundary\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ElementaryEntity-Tuple{Any, Any}","page":"Home","title":"WavePropBase.ElementaryEntity","text":"ElementaryEntity(dim,tag)\n\nConstruct an ElementaryEntity with an empty boundary .\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.HyperRectangle","page":"Home","title":"WavePropBase.HyperRectangle","text":"HyperRectangle{N,T}\n\nHyperrectangle in N dimensions described by low_corner::SVector{N,T} and high_corner::SVector{N,T}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Point1D","page":"Home","title":"WavePropBase.Point1D","text":"const Point1D\nconst Point1D(x1)\n\nA point in 1D space, stored in a StaticArray. Point1D = SVector{1, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Point2D","page":"Home","title":"WavePropBase.Point2D","text":"const Point2D\nconst Point2D(x1, x2)\nconst Point2D(x::NTuple{2, Float64})\n\nA point in 2D space, stored in a StaticArray. Point2D = SVector{2, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Point3D","page":"Home","title":"WavePropBase.Point3D","text":"const Point3D\nconst Point3D(x1, x2, x3)\nconst Point3D(x::NTuple{3, Float64})\n\nA point in 3D space, stored in a StaticArray. Point3D = SVector{3, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceLine","page":"Home","title":"WavePropBase.ReferenceLine","text":"struct ReferenceLine\n\nSingleton type representing the [0,1] segment.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceShape","page":"Home","title":"WavePropBase.ReferenceShape","text":"abstract type ReferenceShape{N}\n\nSingleton types defining a referene domain/shape in ℜᴺ. Typically used to define more complex shapes as transformations mapping an ReferenceShape into some region of ℜᴹ through a given map.\n\nSee e.g. ReferenceLine or ReferenceTriangle for examples of concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceSquare","page":"Home","title":"WavePropBase.ReferenceSquare","text":"struct ReferenceSquare\n\nSingleton type representing the square with vertices (0,0),(0,1),(1,1),(1,0)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceTetrahedron","page":"Home","title":"WavePropBase.ReferenceTetrahedron","text":"struct ReferenceTetrahedron\n\nSingleton type representing the tetrahedron with vertices (0,0,0),(0,0,1),(0,1,0),(1,0,0)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceTriangle","page":"Home","title":"WavePropBase.ReferenceTriangle","text":"struct ReferenceTriangle\n\nSingleton type representing the triangle with vertices (0,0),(0,1),(1,0)\n\n\n\n\n\n","category":"type"},{"location":"#Base.:==-Tuple{WavePropBase.AbstractEntity, WavePropBase.AbstractEntity}","page":"Home","title":"Base.:==","text":"==(Ω1::AbstractEntity,Ω2::AbstractEntity)\n\nTwo elementary entities are considered equal if their dim and tag fields match.\n\nNotice that this implies dim and tag of an elementary entity should uniquely define it, and therefore global variables like TAGS are needed to make sure newly created AbstractEntities have a new (dim,tag) identifier.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase._new_tag-Tuple{Any}","page":"Home","title":"WavePropBase._new_tag","text":"_new_tag(dim)\n\nGenerate a unique tag for an AbstractEntity of dimension dim.\n\nThe implementation consists of adding one to the maximum value of TAGS[dim]\n\nSee also: TAGS.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.abstractmethod-Tuple{DataType}","page":"Home","title":"WavePropBase.abstractmethod","text":"abstractmethod\n\nA method of an abstract type for which concrete subtypes are expected to provide an implementation.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.assert_extension","page":"Home","title":"WavePropBase.assert_extension","text":"assert_extension(fname,ext,[msg])\n\nCheck that fname is of extension ext. Print the message msg as an assertion error otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.blockmatrix_to_matrix-Union{Tuple{Matrix{B}}, Tuple{B}} where B<:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})","page":"Home","title":"WavePropBase.blockmatrix_to_matrix","text":"blockmatrix_to_matrix(A::Matrix{B}) where {B<:SMatrix}\n\nConvert a Matrix{B}, where B<:SMatrix, to the equivalent Matrix{T}, where T = eltype(B)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.blockvector_to_vector-Union{Tuple{Vector{B}}, Tuple{B}} where B<:(StaticArrays.SVector{S, T} where {S, T})","page":"Home","title":"WavePropBase.blockvector_to_vector","text":"blockvector_to_vector(A::Vector{B}) where {B<:SVector}\n\nConvert a Vector{B}, where B<:SVector, to the equivalent Vector{T}, where T = eltype(B)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.boundary-Tuple{WavePropBase.ElementaryEntity}","page":"Home","title":"WavePropBase.boundary","text":"boundary(ω::ElementaryEntity)\n\nReturn the vector of elementary entities making the boundary.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.bounding_box-Tuple{Vector{var\"#s2\"} where var\"#s2\"<:(StaticArrays.SVector{S, T} where {S, T})}","page":"Home","title":"WavePropBase.bounding_box","text":"bounding_box(data::Vector{<:SVector})\n\nCreate a HyperRectangle to bound the points in data.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.enable_debug-Tuple{Any}","page":"Home","title":"WavePropBase.enable_debug","text":"enable_debug(mname)\n\nActivate debugging messages by setting the environment variable JULIA_DEBUG to mname.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.key-Tuple{WavePropBase.ElementaryEntity}","page":"Home","title":"WavePropBase.key","text":"key(ω::ElementaryEntity)\n\nReturn the unique (dim,tag) key for the elementary entity.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.matrix_to_blockmatrix-Tuple{Matrix{T} where T, Type{var\"#s1\"} where var\"#s1\"<:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})}","page":"Home","title":"WavePropBase.matrix_to_blockmatrix","text":"matrix_to_blockmatrix(A::Matrix,B)\n\nConvert a Matrix{T} to a Matrix{B}, where B<:Type{SMatrix}. The element type of B must match that of A, and the size of A must be divisible by the size of B along each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.notimplemented-Tuple{}","page":"Home","title":"WavePropBase.notimplemented","text":"notimplemented()\n\nThings which should probably be implemented at some point.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.print_threads_info-Tuple{}","page":"Home","title":"WavePropBase.print_threads_info","text":"print_threads_info()\n\nPrints in console the total number of threads.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.sort_by_type-Tuple{Any}","page":"Home","title":"WavePropBase.sort_by_type","text":"sort_by_type(v)\n\nSort the elements of v into vectors vi according to their type. Return a Dict{DataType,Vector} mapping each type to a vector of that type.\n\nExamples\n\nv = [1,\"a\",3,\"b\"]\ndict = sort_by_type(v)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.svector-Tuple{Any, Any}","page":"Home","title":"WavePropBase.svector","text":"svector(f,n)\n\nJust like Base.ntuple, but convert output to an SVector.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.vector_to_blockvector-Tuple{Vector{T} where T, Type{var\"#s3\"} where var\"#s3\"<:(StaticArrays.SVector{S, T} where {S, T})}","page":"Home","title":"WavePropBase.vector_to_blockvector","text":"vector_to_blockvector(A::Vector,B)\n\nConvert a Vector{T} to a Vector{B}, where B<:Type{SVector}. The element type of B must match that of A, and the size of A must be divisible by the size of B along each dimension.\n\n\n\n\n\n","category":"method"}]
}

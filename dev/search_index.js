var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = WavePropBase","category":"page"},{"location":"#WavePropBase","page":"Home","title":"WavePropBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase]","category":"page"},{"location":"#WavePropBase.SType","page":"Home","title":"WavePropBase.SType","text":"const SType{T}\n\nUnion type of T and its data type Type{T}. Used to simplify methods defined on singleton types where both foo(::T) and foo(::Type{T}) are required.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.AbstractReferenceShape","page":"Home","title":"WavePropBase.AbstractReferenceShape","text":"abstract type AbstractReferenceShape{N}\n\nA reference domain/shape in ℜᴺ.\n\nUsed mostly for defining more complex shapes as transformations mapping an AbstractReferenceShape into some region of ℜᴹ.\n\nSee e.g. ReferenceLine or ReferenceTriangle for some examples of concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ComplexPoint2D","page":"Home","title":"WavePropBase.ComplexPoint2D","text":"const ComplexPoint2D\nconst ComplexPoint2D(x1, x2)\nconst ComplexPoint2D(x::NTuple{2, ComplexF64})\n\nA complex 2D point, stored in a StaticArray. ComplexPoint2D = SVector{2, ComplexF64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ComplexPoint3D","page":"Home","title":"WavePropBase.ComplexPoint3D","text":"const ComplexPoint3D\nconst ComplexPoint3D(x1, x2, x3)\nconst ComplexPoint3D(x::NTuple{3, ComplexF64})\n\nA complex 3D point, stored in a StaticArray. ComplexPoint3D = SVector{3, ComplexF64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Point2D","page":"Home","title":"WavePropBase.Point2D","text":"const Point2D\nconst Point2D(x1, x2)\nconst Point2D(x::NTuple{2, Float64})\n\nA point in 2D space, stored in a StaticArray. Point2D = SVector{2, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Point3D","page":"Home","title":"WavePropBase.Point3D","text":"const Point3D\nconst Point3D(x1, x2, x3)\nconst Point3D(x::NTuple{3, Float64})\n\nA point in 3D space, stored in a StaticArray. Point3D = SVector{3, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceLine","page":"Home","title":"WavePropBase.ReferenceLine","text":"struct ReferenceLine\n\nSingleton type representing the [0,1] segment.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceSquare","page":"Home","title":"WavePropBase.ReferenceSquare","text":"struct ReferenceSquare\n\nSingleton type representing the square with vertices (0,0),(0,1),(1,1),(1,0)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceTetrahedron","page":"Home","title":"WavePropBase.ReferenceTetrahedron","text":"struct ReferenceTetrahedron\n\nSingleton type representing the tetrahedron with vertices (0,0,0),(0,0,1),(0,1,0),(1,0,0)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceTriangle","page":"Home","title":"WavePropBase.ReferenceTriangle","text":"struct ReferenceTriangle\n\nSingleton type representing the triangle with vertices (0,0),(0,1),(1,0)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.abstractmethod-Tuple{DataType}","page":"Home","title":"WavePropBase.abstractmethod","text":"abstractmethod\n\nA method of an abstract type for which concrete subtypes are expected to provide an implementation.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.assert_extension","page":"Home","title":"WavePropBase.assert_extension","text":"assert_extension(fname,ext,[msg])\n\nCheck that fname is of extension ext. Print the message msg as an assertion error otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.blockmatrix_to_matrix-Union{Tuple{Matrix{B}}, Tuple{B}} where B<:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})","page":"Home","title":"WavePropBase.blockmatrix_to_matrix","text":"blockmatrix_to_matrix(A::Matrix{B}) where {B<:SMatrix}\n\nConvert a Matrix{B}, where B<:SMatrix, to the equivalent Matrix{T}, where T = eltype(B)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.blockvector_to_vector-Union{Tuple{Vector{B}}, Tuple{B}} where B<:(StaticArrays.SVector{S, T} where {S, T})","page":"Home","title":"WavePropBase.blockvector_to_vector","text":"blockvector_to_vector(A::Vector{B}) where {B<:SVector}\n\nConvert a Vector{B}, where B<:SVector, to the equivalent Vector{T}, where T = eltype(B)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.enable_debug-Tuple{Any}","page":"Home","title":"WavePropBase.enable_debug","text":"enable_debug(mname)\n\nActivate debugging messages by setting the environment variable JULIA_DEBUG to mname.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.matrix_to_blockmatrix-Tuple{Matrix{T} where T, Type{var\"#s1\"} where var\"#s1\"<:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})}","page":"Home","title":"WavePropBase.matrix_to_blockmatrix","text":"matrix_to_blockmatrix(A::Matrix,B)\n\nConvert a Matrix{T} to a Matrix{B}, where B<:Type{SMatrix}. The element type of B must match that of A, and the size of A must be divisible by the size of B along each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.notimplemented-Tuple{}","page":"Home","title":"WavePropBase.notimplemented","text":"notimplemented()\n\nThings which should probably be implemented at some point.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.print_threads_info-Tuple{}","page":"Home","title":"WavePropBase.print_threads_info","text":"print_threads_info()\n\nPrints in console the total number of threads.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.svector-Tuple{Any, Any}","page":"Home","title":"WavePropBase.svector","text":"svector(f,n)\n\nJust like Base.ntuple, but convert output to an SVector.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.vector_to_blockvector-Tuple{Vector{T} where T, Type{var\"#s3\"} where var\"#s3\"<:(StaticArrays.SVector{S, T} where {S, T})}","page":"Home","title":"WavePropBase.vector_to_blockvector","text":"vector_to_blockvector(A::Vector,B)\n\nConvert a Vector{T} to a Vector{B}, where B<:Type{SVector}. The element type of B must match that of A, and the size of A must be divisible by the size of B along each dimension.\n\n\n\n\n\n","category":"method"}]
}

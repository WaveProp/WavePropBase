var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = WavePropBase","category":"page"},{"location":"#WavePropBase","page":"Home","title":"WavePropBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase]","category":"page"},{"location":"#WavePropBase.ENTITIES","page":"Home","title":"WavePropBase.ENTITIES","text":"const ENTITIES\n\nGlobal dictionary storing the used entity tags (the value) for a given dimension (the key).\n\n\n\n\n\n","category":"constant"},{"location":"#WavePropBase.SType","page":"Home","title":"WavePropBase.SType","text":"const SType{T} = Union{T,Type{T}}\n\nUnion type of T and its data type Type{T}. Used to simplify methods defined on singleton types where both foo(::T) and foo(::Type{T}) are required.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.TAGS","page":"Home","title":"WavePropBase.TAGS","text":"const TAGS::Dict{Int,Vector{Int}}\n\nGlobal dictionary storing the used entity tags (the value) for a given dimension (the key).\n\n\n\n\n\n","category":"constant"},{"location":"#WavePropBase.AbstractElement","page":"Home","title":"WavePropBase.AbstractElement","text":"abstract type AbstractElement{D,T}\n\nAbstract element given by an interpolation scheme of return_type T over the domain D<:ReferenceShape.\n\nInstances el of AbstractElement are expected to implement:\n\nel(x̂): evaluate the interpolation scheme at the coordinate x̂ ∈ D.\njacobian(el,x̂) : evaluate the jacobian matrix of the interpolation at the   coordinate x ∈ D.\n\nnote: Note\nFor performance reasons, both el(x̂) and jacobian(el,x̂) should typically operate on static arrays/vectors.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.AbstractEntity","page":"Home","title":"WavePropBase.AbstractEntity","text":"abstract type AbstractEntity\n\nEntity of geometrical nature. Identifiable throught its (dim,tag) key.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.AbstractMesh","page":"Home","title":"WavePropBase.AbstractMesh","text":"abstract type AbstractMesh{N,T}\n\nAn abstract parent structure in dimension N with primite data of type T (e.g. Float64 for double precision representation).\n\nThe AbstractMesh interface expects the following methods to be implemented:\n\nkeys(msh) : return a list of the element types composing the mesh.\nmsh[E]    : return an ElementIterator for the mesh elements of type E\n\nSee also: ElementIterator\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.CartesianMesh","page":"Home","title":"WavePropBase.CartesianMesh","text":"struct CartesianMesh{N,T} <: AbstractMesh{N,T}\n\nAn N-dimensional cartesian grid given as the tensor-product of N one-dimensional Vector{T} grids.\n\nIterating over a CartesianMesh generates the elements which compose the mesh; i.e. the HyperRectangle cells.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.CartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{HyperRectangle{N, T}, Tuple{Vararg{T, N}} where T}} where {N, T}","page":"Home","title":"WavePropBase.CartesianMesh","text":"CartesianMesh(;domain::HyperRectangle,sz::NTuple)\n\nConstruct a uniform CartesianMesh with sz[d] elements along dimension d.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.ComplexPoint2D","page":"Home","title":"WavePropBase.ComplexPoint2D","text":"const ComplexPoint2D\nconst ComplexPoint2D(x1, x2)\nconst ComplexPoint2D(x::NTuple{2, ComplexF64})\n\nA complex 2D point, stored in a StaticArray. ComplexPoint2D = SVector{2, ComplexF64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ComplexPoint3D","page":"Home","title":"WavePropBase.ComplexPoint3D","text":"const ComplexPoint3D\nconst ComplexPoint3D(x1, x2, x3)\nconst ComplexPoint3D(x::NTuple{3, ComplexF64})\n\nA complex 3D point, stored in a StaticArray. ComplexPoint3D = SVector{3, ComplexF64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Domain","page":"Home","title":"WavePropBase.Domain","text":"struct Domain\n\nRepresent a physical domain as a union of entities.\n\nSee also: AbstractEntity, ElementaryEntity.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ElementIterator","page":"Home","title":"WavePropBase.ElementIterator","text":"struct ElementIterator{E,M}\n\nReturn an iterator for all elements of type E on a mesh of type M.\n\nBesides the methods listed in the iterator iterface of Julia, some functions also require the getindex(iter,i::Int) method for accessing the i-th element directly.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ElementaryEntity","page":"Home","title":"WavePropBase.ElementaryEntity","text":"struct ElementaryEntity <: AbstractEntity\n\nThe most basic representation of an AbstractEntity.\n\nFields:\n\ndim::UInt8: the geometrical dimension of the entity (e.g. line has dim=1, surface has dim=2, etc)\ntag::Int64: an integer tag associated to the entity\nboundary::Vector{ElementaryEntity}: the entities of dimension dim-1 forming the entity's boundary\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ElementaryEntity-Tuple{Any, Any}","page":"Home","title":"WavePropBase.ElementaryEntity","text":"ElementaryEntity(dim,tag)\n\nConstruct an ElementaryEntity with an empty boundary .\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.GenericMesh","page":"Home","title":"WavePropBase.GenericMesh","text":"struct GenericMesh{N,T} <: AbstractMesh{N,T}\n\nData structure representing a generic mesh in an ambient space of dimension N, with data of type T.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.HyperRectangle","page":"Home","title":"WavePropBase.HyperRectangle","text":"HyperRectangle{N,T}\n\nHyperrectangle in N dimensions described by a low_corner::SVector{N,T} and a high_corner::SVector{N,T}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.LagrangeElement","page":"Home","title":"WavePropBase.LagrangeElement","text":"struct LagrangeElement{D,Np,T} <: AbstractElement{D,T}\n\nFields:\n\nvals::SVector{Np,T}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.LagrangeInterp","page":"Home","title":"WavePropBase.LagrangeInterp","text":"struct LagrangeInterp{N,Td,T}\n\nGeneric Lagrange interpolation over an N-dimensional tensor grid. The implementation uses a multidimensional generalization of the barycentric formula.\n\nThe main constructor takes an SVector{N,Vector{Td}} containig the N one-dimensional nodes and an Array{N,T} of the function vals at the tensor product grid formed by the one-dimensional nodes.\n\nExamples:\n\nnx = 10\nny = 12\nx   = [0.5+0.5cos((2k-1)*π/2nx) for k in 1:nx] # Chebyshev nodes\ny   = [0.5+0.5cos((2k-1)*π/2ny) for k in 1:ny] # Chebyshev nodes\nf   = (x) -> cos(x[1]*x[2])\nvals = [f((x,y)) for x in x, y in y]\np   = LagrangeInterp(SVector(x,y),vals)\np((0.1,0.2)) ≈ f((0.1,0.2))\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.LagrangeLine","page":"Home","title":"WavePropBase.LagrangeLine","text":"const LagrangeLine = LagrangeElement{ReferenceLine}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.LagrangeRectangle","page":"Home","title":"WavePropBase.LagrangeRectangle","text":"const LagrangeRectangle = LagrangeElement{ReferenceSquare}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.LagrangeTetrahedron","page":"Home","title":"WavePropBase.LagrangeTetrahedron","text":"const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.LagrangeTriangle","page":"Home","title":"WavePropBase.LagrangeTriangle","text":"const LagrangeTriangle = LagrangeElement{ReferenceTriangle}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Point1D","page":"Home","title":"WavePropBase.Point1D","text":"const Point1D\nconst Point1D(x1)\n\nA point in 1D space, stored in a StaticArray. Point1D = SVector{1, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Point2D","page":"Home","title":"WavePropBase.Point2D","text":"const Point2D\nconst Point2D(x1, x2)\nconst Point2D(x::NTuple{2, Float64})\n\nA point in 2D space, stored in a StaticArray. Point2D = SVector{2, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Point3D","page":"Home","title":"WavePropBase.Point3D","text":"const Point3D\nconst Point3D(x1, x2, x3)\nconst Point3D(x::NTuple{3, Float64})\n\nA point in 3D space, stored in a StaticArray. Point3D = SVector{3, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceLine","page":"Home","title":"WavePropBase.ReferenceLine","text":"struct ReferenceLine\n\nSingleton type representing the [0,1] segment.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceShape","page":"Home","title":"WavePropBase.ReferenceShape","text":"abstract type ReferenceShape{N}\n\nSingleton types defining a referene domain/shape in ℜᴺ. Typically used to define more complex shapes as transformations mapping an ReferenceShape into some region of ℜᴹ through a given map.\n\nSee e.g. ReferenceLine or ReferenceTriangle for examples of concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceSquare","page":"Home","title":"WavePropBase.ReferenceSquare","text":"struct ReferenceSquare\n\nSingleton type representing the square with vertices (0,0),(0,1),(1,1),(1,0)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceTetrahedron","page":"Home","title":"WavePropBase.ReferenceTetrahedron","text":"struct ReferenceTetrahedron\n\nSingleton type representing the tetrahedron with vertices (0,0,0),(0,0,1),(0,1,0),(1,0,0)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.ReferenceTriangle","page":"Home","title":"WavePropBase.ReferenceTriangle","text":"struct ReferenceTriangle\n\nSingleton type representing the triangle with vertices (0,0),(0,1),(1,0)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.SubMesh","page":"Home","title":"WavePropBase.SubMesh","text":"struct SubMesh{N,T} <: AbstractMesh{N,T}\n\nCreate a view of a parent mesh over a given domain.\n\nA submesh implements the interface for AbstractMesh; therefore you can iterate over elements of the submesh just like you would with a mesh.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:==-Tuple{AbstractEntity, AbstractEntity}","page":"Home","title":"Base.:==","text":"==(Ω1::AbstractEntity,Ω2::AbstractEntity)\n\nTwo elementary entities are considered equal geometric_dimension(Ω1)==geometric_dimension(Ω2) and abs(tag(Ω1))=abs(tag(Ω2)). The sign of tag(Ω) is used to determine its orientation.\n\nNotice that this implies dim and tag of an elementary entity should uniquely define it (up to the sign of tag), and therefore global variables like TAGS are needed to make sure newly created AbstractEntities have a new (dim,tag) identifier.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Domain, Domain}","page":"Home","title":"Base.:==","text":"===(Ω1::Domain,Ω2::Domain)\n\nTwo Domains are equal if all their entities are equal (regardless of order).\n\n\n\n\n\n","category":"method"},{"location":"#Base.in-Tuple{ElementaryEntity, Domain}","page":"Home","title":"Base.in","text":"in(ω::ElementaryEntity,Ω::Domain)\n\nCheck whether an ElementaryEntity belongs to a Domain by recursively checking whether it belongs to its boundary.\n\n\n\n\n\n","category":"method"},{"location":"#Base.iterate","page":"Home","title":"Base.iterate","text":"iterate(Ω::Domain)\n\nIterating over a domain means iterating over its entities.\n\n\n\n\n\n","category":"function"},{"location":"#Base.keys-Tuple{Domain, Integer}","page":"Home","title":"Base.keys","text":"Return all tags of the elementary entities in the domain Ω corresponding to the dimension d.\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Union{Tuple{T}, Tuple{Domain, Vector{T}}} where T<:Integer","page":"Home","title":"Base.keys","text":"Return all tags of the elementary entities in the domain Ω corresponding to the dimensions contained in dims.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{Domain}","page":"Home","title":"Base.length","text":"length(Ω:::Domain)\n\nThe length of a domain corresponds to the number of elementary entities that make it.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.abstractmethod-Tuple{DataType}","page":"Home","title":"WavePropBase.abstractmethod","text":"abstractmethod\n\nA method of an abstract type for which concrete subtypes are expected to provide an implementation.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.ambient_dimension","page":"Home","title":"WavePropBase.ambient_dimension","text":"ambient_dimension(x)\n\nDimension of the ambient space where x lives. For geometrical objects this can differ from its geometric_dimension; for example a triangle in ℝ³ has ambient dimension 3 but geometric dimension 2, while a curve in ℝ³ has ambient dimension 3 but geometric dimension 1.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.assert_extension","page":"Home","title":"WavePropBase.assert_extension","text":"assert_extension(fname,ext,[msg])\n\nCheck that fname is of extension ext. Print the message msg as an assertion error otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.assertequaldim-Tuple{Domain, Domain}","page":"Home","title":"WavePropBase.assertequaldim","text":"assertequaldim(Ω1::Domain,Ω2::Domain)\n\nCheck that two domains have same dimension.\n\nIf one of the domain (or both) are empty, the assertion is assumed to be true.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.blockmatrix_to_matrix-Union{Tuple{Matrix{B}}, Tuple{B}} where B<:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})","page":"Home","title":"WavePropBase.blockmatrix_to_matrix","text":"blockmatrix_to_matrix(A::Matrix{B}) where {B<:SMatrix}\n\nConvert a Matrix{B}, where B<:SMatrix, to the equivalent Matrix{T}, where T = eltype(B)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.blockvector_to_vector-Union{Tuple{Vector{B}}, Tuple{B}} where B<:(StaticArrays.SVector{S, T} where {S, T})","page":"Home","title":"WavePropBase.blockvector_to_vector","text":"blockvector_to_vector(A::Vector{B}) where {B<:SVector}\n\nConvert a Vector{B}, where B<:SVector, to the equivalent Vector{T}, where T = eltype(B)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.boundary","page":"Home","title":"WavePropBase.boundary","text":"boundary(ω)\n\nReturn the boundary of ω. For a mesh element gives the d-1 dimensional elements composing its boundary, while for an entity gives the corresponding d-1 dimensional entities.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.bounding_box-Tuple{Vector{var\"#s2\"} where var\"#s2\"<:(StaticArrays.SVector{S, T} where {S, T})}","page":"Home","title":"WavePropBase.bounding_box","text":"bounding_box(data)\n\nCreate a HyperRectangle to bound the points in data.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.center","page":"Home","title":"WavePropBase.center","text":"center(Ω)\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.clear_entities!-Tuple{}","page":"Home","title":"WavePropBase.clear_entities!","text":"clear_entities!()\n\nEmpty the global variables used to keep track of the various entities created.\n\nSee also: ENTITIES, TAGS\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.degree-Union{Tuple{Type{LagrangeLine{Np, T}}}, Tuple{T}, Tuple{Np}} where {Np, T}","page":"Home","title":"WavePropBase.degree","text":"degree(el::LagrangeElement)\n\nThe degree of the underlying polynomial used to represent this type of element.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.diameter","page":"Home","title":"WavePropBase.diameter","text":"diameter(Ω)\n\nLargest distance between x and y for x,y ∈ Ω.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.dom2elt-Tuple{GenericMesh, Any, DataType}","page":"Home","title":"WavePropBase.dom2elt","text":"dom2elt(m::GenericMesh,Ω,E)\n\nCompute the element indices idxs of the elements of type E composing Ω, so that m[E][idxs] gives all the elements of type E meshing Ω.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.dom2elt-Tuple{GenericMesh, Any}","page":"Home","title":"WavePropBase.dom2elt","text":"dom2elt(m::GenericMesh,Ω)\n\nReturn a Dict with keys being the element types of m, and values being the indices of the elements in Ω of that type.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.dom2elt-Tuple{WavePropBase.SubMesh}","page":"Home","title":"WavePropBase.dom2elt","text":"dom2elt(m::SubMesh,[E])\n\nA dictionary with keys being the element types of m, and values being the element indices in the parent mesh. If a type E is given, return the values associated with that key.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.domain","page":"Home","title":"WavePropBase.domain","text":"domain(f)\n\nThe domain of f. For elements of geometrical nature return the ReferenceShape used to represent it.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.enable_debug-Tuple{Any}","page":"Home","title":"WavePropBase.enable_debug","text":"enable_debug(mname)\n\nActivate debugging messages by setting the environment variable JULIA_DEBUG to mname.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.entities-Tuple{Domain}","page":"Home","title":"WavePropBase.entities","text":"entities(Ω::Domain)\n\nReturn a vector of all elementary entities making up a domain.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.external_boundary-Tuple{Domain}","page":"Home","title":"WavePropBase.external_boundary","text":"Return the external boundaries inside a domain.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.geometric_dimension","page":"Home","title":"WavePropBase.geometric_dimension","text":"geometric_dimension(x)\ngeometric_dimension(Ω::Domain)\n\nNumber of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in ℝ² or in ℝ³), while surfaces have geometric dimension of 2.\n\nWhen the argument is a Domain, return the largest geometric dimension encoutered.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.internal_boundary-Tuple{Domain}","page":"Home","title":"WavePropBase.internal_boundary","text":"Return the internal boundaries inside a domain.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.jacobian","page":"Home","title":"WavePropBase.jacobian","text":"jacobian(F,x̂)\n\nThe Jacobian matrix Aᵢⱼ = ∂Fᵢ/∂x̂ⱼ at the parametric coordinate x̂.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.key-Tuple{AbstractEntity}","page":"Home","title":"WavePropBase.key","text":"key(e::AbstractEntity)\n\nThe (dim,tag) pair used as a key to identify various abstract entities.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.matrix_to_blockmatrix-Tuple{Matrix{T} where T, Type{var\"#s1\"} where var\"#s1\"<:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})}","page":"Home","title":"WavePropBase.matrix_to_blockmatrix","text":"matrix_to_blockmatrix(A::Matrix,B)\n\nConvert a Matrix{T} to a Matrix{B}, where B<:Type{SMatrix}. The element type of B must match that of A, and the size of A must be divisible by the size of B along each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.new_tag-Tuple{Any}","page":"Home","title":"WavePropBase.new_tag","text":"new_tag(dim)\n\nGenerate a unique tag for an AbstractEntity of dimension dim.\n\nThe implementation consists of adding one to the maximum value of TAGS[dim]\n\nSee also: TAGS.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.normal","page":"Home","title":"WavePropBase.normal","text":"normal(el,x̂)\n\nThe unit normal vector of el at the parametric coordinate x̂.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.notimplemented-Tuple{}","page":"Home","title":"WavePropBase.notimplemented","text":"notimplemented()\n\nThings which should probably be implemented at some point.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.print_threads_info-Tuple{}","page":"Home","title":"WavePropBase.print_threads_info","text":"print_threads_info()\n\nPrints in console the total number of threads.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.radius","page":"Home","title":"WavePropBase.radius","text":"radius(Ω)\n\nHalf the diameter.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.reference_nodes","page":"Home","title":"WavePropBase.reference_nodes","text":"reference_nodes(::LagrangeElement{D,Np,T})\n\nReturn the reference nodes on D used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.\n\nWe use the same convention as gmsh for defining the reference nodes and their order (see node ordering on gmsh documentation).\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.return_type","page":"Home","title":"WavePropBase.return_type","text":"return_type(f)\n\nThe type returned by the function-like object f.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.skeleton-Tuple{Domain}","page":"Home","title":"WavePropBase.skeleton","text":"skeleton(Ω::Domain)\n\nReturn all the boundaries of the domain, i.e. the domain's skeleton.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.sort_by_type-Tuple{Any}","page":"Home","title":"WavePropBase.sort_by_type","text":"sort_by_type(v)\n\nSort the elements of v into vectors vi according to their type. Return a Dict{DataType,Vector} mapping each type to a vector of that type.\n\nExamples\n\nv = [1,\"a\",3,\"b\"]\ndict = sort_by_type(v)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.svector-Tuple{Any, Any}","page":"Home","title":"WavePropBase.svector","text":"svector(f,n)\n\nJust like Base.ntuple, but convert output to an SVector.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.tag","page":"Home","title":"WavePropBase.tag","text":"tag(::AbstractEntity)\n\nInteger tag used to idetify geometrical entities.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.vector_to_blockvector-Tuple{Vector{T} where T, Type{var\"#s3\"} where var\"#s3\"<:(StaticArrays.SVector{S, T} where {S, T})}","page":"Home","title":"WavePropBase.vector_to_blockvector","text":"vector_to_blockvector(A::Vector,B)\n\nConvert a Vector{T} to a Vector{B}, where B<:Type{SVector}. The element type of B must match that of A, and the size of A must be divisible by the size of B along each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.@interface","page":"Home","title":"WavePropBase.@interface","text":"@interface f [n=1]\n\nDeclare that the function f is an interface function. The call f(args...) resolves to M.f(args...) where M is parent module of the args[n] object.\n\nThe somewhat contrived example below illustrates how this can be used to have a generic method defined in module A applied to a type defined on module B which is independent of A but which implements the interface function f:\n\nmodule A\n    using WavePropBase\n    WavePropBase.@interface foo\n    # a method which works on any type `x` implementing the `foo` function\n    do_work(x) = 2*foo(x)\nend\n\nmodule B\n    struct Foo end\n    foo(x::Foo) = 1\nend\n\nusing .A\nusing .B\nfoo = B.Foo()\nA.do_work(foo)\n\n# output\n\n2\n\nNote that if in the example above module A implements a generic version of foo, the call A.do_work(foo) would use that method instead based on the dispatch rules.\n\n\n\n\n\n","category":"macro"}]
}

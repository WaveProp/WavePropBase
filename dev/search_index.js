var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = WavePropBase","category":"page"},{"location":"#WavePropBase","page":"Home","title":"WavePropBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase, WavePropBase.Geometry]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase]","category":"page"},{"location":"#WavePropBase.ambient_dimension","page":"Home","title":"WavePropBase.ambient_dimension","text":"ambient_dimension(x)\n\nDimension of the ambient space where x lives. For geometrical objects this can differ from its geometric_dimension; for example a triangle in ‚Ñù¬≥ has ambient dimension 3 but geometric dimension 2, while a curve in ‚Ñù¬≥ has ambient dimension 3 but geometric dimension 1.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.boundary","page":"Home","title":"WavePropBase.boundary","text":"boundary(œâ)\n\nReturn the boundary of œâ. For a mesh element gives the d-1 dimensional elements composing its boundary, while for an entity gives the corresponding d-1 dimensional entities.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.bounding_box","page":"Home","title":"WavePropBase.bounding_box","text":"bounding_box(data)\n\nCreate an axis-aligned bounding box containing all of data.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.center","page":"Home","title":"WavePropBase.center","text":"center(Œ©)\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.coords","page":"Home","title":"WavePropBase.coords","text":"coords(x)\n\nReturn an SVector giving a cartesian coordinate used to sort x. For points, this is simply the coordinates of the point, while for elements this may be the center of the element. You must overload this function for your own type if you want e.g. the clustering algorithms to work for x.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.diameter","page":"Home","title":"WavePropBase.diameter","text":"diameter(Œ©)\n\nLargest distance between x and y for x,y ‚àà Œ©.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.dimension","page":"Home","title":"WavePropBase.dimension","text":"dimension(space)\n\nThe length of a basis for space; i.e. the number of linearly independent elements required to span space.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.domain","page":"Home","title":"WavePropBase.domain","text":"domain(f)\n\nThe domain of the function f.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.entities","page":"Home","title":"WavePropBase.entities","text":"entities(Œ©::Domain)\nentities(M::AbstractMesh)\n\nReturn the geometrical entities composing Œ©.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.flip_normal","page":"Home","title":"WavePropBase.flip_normal","text":"flip_normal(e::AbstractEntity)\n\nFlip the orientation of the normal vector.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.geometric_dimension","page":"Home","title":"WavePropBase.geometric_dimension","text":"geometric_dimension(x)\ngeometric_dimension(Œ©::Domain)\n\nNumber of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in ‚Ñù¬≤ or in ‚Ñù¬≥), while surfaces have geometric dimension of 2.\n\nWhen the argument is a Domain, return the largest geometric dimension encoutered.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.image","page":"Home","title":"WavePropBase.image","text":"image(f)\n\nThe image of the function f.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.jacobian","page":"Home","title":"WavePropBase.jacobian","text":"jacobian(f,x)\n\nGiven a (possibly vector-valued) function f : ùêë·µê ‚Üí ùêÖ·µê, return the m √ó n matrix A·µ¢‚±º = ‚àÇf·µ¢/‚àÇxÃÇ‚±º.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.meshgen","page":"Home","title":"WavePropBase.meshgen","text":"meshgen(Œ©::Domain)\n\nGenerate a mesh for Œ©.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.normal","page":"Home","title":"WavePropBase.normal","text":"normal(el,xÃÇ)\nnormal(jac::SMatrix)\n\nThe unit normal vector at coordinate xÃÇ, guaranteed to be orthogonal to all columns of jacobian(el,x).\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.parametrization","page":"Home","title":"WavePropBase.parametrization","text":"parametrization(el)\n\nReturn the underlying parametrization of el.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.radius","page":"Home","title":"WavePropBase.radius","text":"radius(Œ©)\n\nHalf the diameter.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.reference_nodes","page":"Home","title":"WavePropBase.reference_nodes","text":"reference_nodes(::LagrangeElement{D,Np,T})\n\nReturn the reference nodes on D used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.\n\nWe use the same convention as gmsh for defining the reference nodes and their order (see node ordering on gmsh documentation).\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.return_type","page":"Home","title":"WavePropBase.return_type","text":"return_type(f)\n\nThe type returned by the function-like object f.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.tag","page":"Home","title":"WavePropBase.tag","text":"tag(::AbstractEntity)\n\nInteger tag commonly used to idetify geometrical entities.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.weight","page":"Home","title":"WavePropBase.weight","text":"weight(q)\n\nFor a quadrature node q, return its weight.\n\n\n\n\n\n","category":"function"},{"location":"#Utils-module","page":"Home","title":"Utils module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase.Utils]","category":"page"},{"location":"#WavePropBase.Utils","page":"Home","title":"WavePropBase.Utils","text":"Utils\n\nModule containing various utility functions for WaveProp.\n\n\n\n\n\n","category":"module"},{"location":"#WavePropBase.Utils.SType","page":"Home","title":"WavePropBase.Utils.SType","text":"const SType{T} = Union{T,Type{T}}\n\nUnion type of T and its data type Type{T}. Used to simplify methods defined on singleton types where both foo(::T) and foo(::Type{T}) are required.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Utils.ComplexPoint2D","page":"Home","title":"WavePropBase.Utils.ComplexPoint2D","text":"const ComplexPoint2D\nconst ComplexPoint2D(x1, x2)\nconst ComplexPoint2D(x::NTuple{2, ComplexF64})\n\nA complex 2D point, stored in a StaticArray. ComplexPoint2D = SVector{2, ComplexF64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Utils.ComplexPoint3D","page":"Home","title":"WavePropBase.Utils.ComplexPoint3D","text":"const ComplexPoint3D\nconst ComplexPoint3D(x1, x2, x3)\nconst ComplexPoint3D(x::NTuple{3, ComplexF64})\n\nA complex 3D point, stored in a StaticArray. ComplexPoint3D = SVector{3, ComplexF64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Utils.Point1D","page":"Home","title":"WavePropBase.Utils.Point1D","text":"const Point1D\nconst Point1D(x1)\n\nA point in 1D space, stored in a StaticArray. Point1D = SVector{1, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Utils.Point2D","page":"Home","title":"WavePropBase.Utils.Point2D","text":"const Point2D\nconst Point2D(x1, x2)\nconst Point2D(x::NTuple{2, Float64})\n\nA point in 2D space, stored in a StaticArray. Point2D = SVector{2, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Utils.Point3D","page":"Home","title":"WavePropBase.Utils.Point3D","text":"const Point3D\nconst Point3D(x1, x2, x3)\nconst Point3D(x::NTuple{3, Float64})\n\nA point in 3D space, stored in a StaticArray. Point3D = SVector{3, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Utils.abstractmethod-Tuple{DataType}","page":"Home","title":"WavePropBase.Utils.abstractmethod","text":"abstractmethod\n\nA method of an abstract type for which concrete subtypes are expected to provide an implementation.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.assert_extension","page":"Home","title":"WavePropBase.Utils.assert_extension","text":"assert_extension(fname,ext,[msg])\n\nCheck that fname is of extension ext. Print the message msg as an assertion error otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.Utils.blockmatrix_to_matrix-Union{Tuple{Matrix{B}}, Tuple{B}} where B<:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})","page":"Home","title":"WavePropBase.Utils.blockmatrix_to_matrix","text":"blockmatrix_to_matrix(A::Matrix{B}) where {B<:SMatrix}\n\nConvert a Matrix{B}, where B<:SMatrix, to the equivalent Matrix{T}, where T = eltype(B)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.blockvector_to_vector-Union{Tuple{Vector{B}}, Tuple{B}} where B<:(StaticArrays.SVector{S, T} where {S, T})","page":"Home","title":"WavePropBase.Utils.blockvector_to_vector","text":"blockvector_to_vector(A::Vector{B}) where {B<:SVector}\n\nConvert a Vector{B}, where B<:SVector, to the equivalent Vector{T}, where T = eltype(B)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.cart2pol-Tuple{Any, Any}","page":"Home","title":"WavePropBase.Utils.cart2pol","text":"cart2pol(x,y)\n\nMap cartesian coordinates x,y to polar coordinates r,Œ∏. The convention followed is that -œÄ ‚â§ Œ∏ ‚â§ œÄ.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.cart2sph-Tuple{Any, Any, Any}","page":"Home","title":"WavePropBase.Utils.cart2sph","text":"cart2sph(x,y,z)\n\nMap cartesian coordinates x,y,z to spherical ones r, Œ∏, œÜ representing the radius, elevation, and azimuthal angle respectively. The convention followed is that 0 ‚â§ Œ∏ ‚â§ œÄ and -œÄ < œÜ ‚â§ œÄ.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.cross_product_matrix-Tuple{Any}","page":"Home","title":"WavePropBase.Utils.cross_product_matrix","text":"cross_product_matrix(v)\n\nReturns the matrix A·µ• associated with the cross product v √ó œï so that v √ó œï = A·µ•œï.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.diagonalblockmatrix_to_matrix-Union{Tuple{AbstractVector{B}}, Tuple{B}} where B<:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})","page":"Home","title":"WavePropBase.Utils.diagonalblockmatrix_to_matrix","text":"diagonalblockmatrix_to_matrix(A::Matrix{B}) where {B<:SMatrix}\n\nConvert a diagonal block matrix A::AbstractVector{B}, where A is the list of diagonal blocks and B<:SMatrix, to the equivalent SparseMatrixCSC{T}, where T = eltype(B).\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.enable_debug-Tuple{}","page":"Home","title":"WavePropBase.Utils.enable_debug","text":"enable_debug(mname)\n\nActivate debugging messages.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.getnodes!-NTuple{4, Any}","page":"Home","title":"WavePropBase.Utils.getnodes!","text":"getnodes!(filter,nodes,tree,[isterminal=true])\n\nLike getnodes, but append valid nodes to nodes.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.matrix_to_blockmatrix-Tuple{Matrix{T} where T, Type{var\"#s1\"} where var\"#s1\"<:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})}","page":"Home","title":"WavePropBase.Utils.matrix_to_blockmatrix","text":"matrix_to_blockmatrix(A::Matrix,B)\n\nConvert a Matrix{T} to a Matrix{B}, where B<:Type{SMatrix}. The element type of B must match that of A, and the size of A must be divisible by the size of B along each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.notimplemented-Tuple{}","page":"Home","title":"WavePropBase.Utils.notimplemented","text":"notimplemented()\n\nThings which should probably be implemented at some point.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.pol2cart-Tuple{Any, Any}","page":"Home","title":"WavePropBase.Utils.pol2cart","text":"pol2cart(r,Œ∏)\n\nMap polar coordinates r,Œ∏ to cartesian coordinates x,y.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.print_threads_info-Tuple{}","page":"Home","title":"WavePropBase.Utils.print_threads_info","text":"print_threads_info()\n\nPrints in console the total number of threads.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.sort_by_type-Tuple{Any}","page":"Home","title":"WavePropBase.Utils.sort_by_type","text":"sort_by_type(v)\n\nSort the elements of v into vectors vi according to their type. Return a Dict{DataType,Vector} mapping each type to a vector of that type.\n\nExamples\n\nv = [1,\"a\",3,\"b\"]\ndict = sort_by_type(v)\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.sph2cart-Tuple{Any, Any, Any}","page":"Home","title":"WavePropBase.Utils.sph2cart","text":"sph2cart(x,y,z)\n\nMap spherical coordinates r,Œ∏,œÜ representing the radius, elevation, and azimuthal angle respectively, to cartesian ones x, y, z .\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.svector-Tuple{Any, Any}","page":"Home","title":"WavePropBase.Utils.svector","text":"svector(f,n)\n\nJust like Base.ntuple, but convert output to an SVector.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Utils.vector_to_blockvector-Tuple{Vector{T} where T, Type{var\"#s3\"} where var\"#s3\"<:(StaticArrays.SVector{S, T} where {S, T})}","page":"Home","title":"WavePropBase.Utils.vector_to_blockvector","text":"vector_to_blockvector(A::Vector,B)\n\nConvert a Vector{T} to a Vector{B}, where B<:Type{SVector}. The element type of B must match that of A, and the size of A must be divisible by the size of B along each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.depth","page":"Home","title":"WavePropBase.depth","text":"depth(node,acc=0)\n\nRecursive function to compute the depth of node in a a tree-like structure. Require the method getparent(node) to be implemented. Overload this function if your structure has a more efficient way to compute depth (e.g. if it stores it in a field).\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.getnodes","page":"Home","title":"WavePropBase.getnodes","text":"getnodes(filter,tree,[isterminal=true])\n\nReturn all the nodes of tree satisfying filter(node)::Bool. If isterminal, do not consider childrens of a node for which filter(block)==true.\n\n\n\n\n\n","category":"function"},{"location":"#WavePropBase.Utils.@interface","page":"Home","title":"WavePropBase.Utils.@interface","text":"@interface f [n=1]\n\nDeclare that the function f is an interface function. The call f(args...) resolves to M.f(args...) where M is parent module of the args[n] object.\n\nThe somewhat contrived example below illustrates how this can be used to have a generic method defined in module A applied to a type defined on module B which is independent of A but which implements the interface function f:\n\nmodule A\n    using WavePropBase.Utils\n    Utils.@interface foo\n    # a method which works on any type `x` implementing the `foo` function\n    do_work(x) = 2*foo(x)\nend\n\nmodule B\n    struct Foo end\n    foo(x::Foo) = 1\nend\n\nusing .A\nusing .B\nfoo = B.Foo()\nA.do_work(foo)\n\n# output\n\n2\n\nNote that if in the example above module A implements a generic version of foo, the call A.do_work(foo) would use that method instead based on the dispatch rules.\n\n\n\n\n\n","category":"macro"},{"location":"#Geometry-module","page":"Home","title":"Geometry module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase.Geometry]","category":"page"},{"location":"#WavePropBase.Geometry","page":"Home","title":"WavePropBase.Geometry","text":"module Geometry\n\nModule defining basic geometrical concepts.\n\n\n\n\n\n","category":"module"},{"location":"#WavePropBase.Geometry.ENTITIES","page":"Home","title":"WavePropBase.Geometry.ENTITIES","text":"const ENTITIES\n\nGlobal dictionary storing the used entity tags (the value) for a given dimension (the key).\n\n\n\n\n\n","category":"constant"},{"location":"#WavePropBase.Geometry.TAGS","page":"Home","title":"WavePropBase.Geometry.TAGS","text":"const TAGS::Dict{Int,Vector{Int}}\n\nGlobal dictionary storing the used entity tags (the value) for a given dimension (the key).\n\n\n\n\n\n","category":"constant"},{"location":"#WavePropBase.Geometry.AbstractEntity","page":"Home","title":"WavePropBase.Geometry.AbstractEntity","text":"abstract type AbstractEntity\n\nEntity of geometrical nature. Identifiable throught its (dim,tag) key.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.AbstractHyperRectangle","page":"Home","title":"WavePropBase.Geometry.AbstractHyperRectangle","text":"abstract type AbstractHyperRectangle{N,T}\n\nAxis-aligned hyperrectangle in N dimensions with coordinates of type SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.AbstractReferenceShape","page":"Home","title":"WavePropBase.Geometry.AbstractReferenceShape","text":"abstract type AbstractReferenceShape{N}\n\nA reference domain/shape in ‚Ñú·¥∫.\n\nUsed mostly for defining more complex shapes as transformations mapping an AbstractReferenceShape into some region of ‚Ñú·¥π.\n\nSee e.g. ReferenceLine or ReferenceTriangle for some examples of concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.AbstractSplitter","page":"Home","title":"WavePropBase.Geometry.AbstractSplitter","text":"abstract type AbstractSplitter\n\nAn AbstractSplitter is used to split a ClusterTree. The interface requires the following methods:\n\nshould_split(clt,splitter) : return a Bool determining if the ClusterTree should be further divided\nsplit!(clt,splitter) : perform the splitting of the ClusterTree handling the necessary data sorting.\n\nSee GeometricSplitter for an example of an implementation.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.CardinalitySplitter","page":"Home","title":"WavePropBase.Geometry.CardinalitySplitter","text":"struct CardinalitySplitter <: AbstractSplitter\n\nUsed to split a ClusterTree along the largest dimension if length(tree)>nmax. The split is performed so the data is evenly distributed amongst all children.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.ClusterTree","page":"Home","title":"WavePropBase.Geometry.ClusterTree","text":"mutable struct ClusterTree{T,S,D}\n\nTree structure used to cluster elements of type T into containers of type S. Instances of T must implement the coords(::T)::SVector method. An additional data field of type D can be associated with each node (it defaults to D=Nothing). \n\nFields:\n\n_elements::T : vector containing the sorted elements.\ncontainer::S : container for the elements in the current node.\nindex_range::UnitRange{Int} : indices of elements contained in the current node.\nloc2glob::Vector{Int} : permutation from global local indexing system to the original (global) indexing system used before the construction of the tree.\nchildren::Vector{ClusterTree{N,T,D}}\nparent::ClusterTree{N,T,D}\ndata::D : generic data field parametrically typed on D.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.ClusterTree-Union{Tuple{D}, Tuple{Any, Any}} where D","page":"Home","title":"WavePropBase.Geometry.ClusterTree","text":"ClusterTree(elements,splitter;[copy_elements=true])\nClusterTree{D}(points,splitter;[copy_elements=true])\n\nConstruct a ClusterTree from the  given elements using the splitting strategy encoded in splitter. If copy_elements is set to false, the elements argument are directly stored in the ClusterTree and are permuted during the tree construction.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.Domain","page":"Home","title":"WavePropBase.Geometry.Domain","text":"struct Domain\n\nRepresent a physical domain as a union of entities.\n\nSee also: AbstractEntity, ElementaryEntity.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.DyadicSplitter","page":"Home","title":"WavePropBase.Geometry.DyadicSplitter","text":"struct DyadicSplitter\n\nUsed to split an N dimensional ClusterTree into 2^N children until at most nmax points are contained in node.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.ElementaryEntity","page":"Home","title":"WavePropBase.Geometry.ElementaryEntity","text":"struct ElementaryEntity <: AbstractEntity\n\nThe most basic representation of an AbstractEntity.\n\nFields:\n\ndim::UInt8: the geometrical dimension of the entity (e.g. line has dim=1, surface has dim=2, etc)\ntag::Int64: an integer tag associated to the entity\nboundary::Vector{AbstractEntity}: the entities of dimension dim-1 forming the entity's boundary\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.ElementaryEntity-Tuple{Any, Any}","page":"Home","title":"WavePropBase.Geometry.ElementaryEntity","text":"ElementaryEntity(dim,tag)\n\nConstruct an ElementaryEntity with an empty boundary .\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.GeometricMinimalSplitter","page":"Home","title":"WavePropBase.Geometry.GeometricMinimalSplitter","text":"struct GeometricMinimalSplitter <: AbstractSplitter\n\nLike GeometricSplitter, but shrinks the children's containters.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.GeometricSplitter","page":"Home","title":"WavePropBase.Geometry.GeometricSplitter","text":"struct GeometricSplitter <: AbstractSplitter\n\nUsed to split a ClusterTree in half along the largest axis.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.HyperCube","page":"Home","title":"WavePropBase.Geometry.HyperCube","text":"struct HyperCube{N,T}\n\nAxis-aligned hypercube in N dimensions given by low_corner::SVector{N,T} and side::T.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.HyperRectangle","page":"Home","title":"WavePropBase.Geometry.HyperRectangle","text":"struct HyperRectangle{N,T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.PointEntity","page":"Home","title":"WavePropBase.Geometry.PointEntity","text":"PointEntity{N,T} <: AbstractEntity\n\nZero-dimension geometrical entity. As a subtype of [AbstractEntity],(@ref) the (dim,tag) of all created point entities get added to the global ENTITIES. Intended usage is to build higher dimensionsional entities, and not to represent regular points such as grid points.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.PrincipalComponentSplitter","page":"Home","title":"WavePropBase.Geometry.PrincipalComponentSplitter","text":"struct PrincipalComponentSplitter <: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.ReferenceLine","page":"Home","title":"WavePropBase.Geometry.ReferenceLine","text":"struct ReferenceLine\n\nSingleton type representing the [0,1] segment.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.ReferencePoint","page":"Home","title":"WavePropBase.Geometry.ReferencePoint","text":"struct ReferencePoint\n\nSingleton type representing a reference zero-dimensional entitty (i.e. a point).\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.ReferenceSquare","page":"Home","title":"WavePropBase.Geometry.ReferenceSquare","text":"struct ReferenceSquare\n\nSingleton type representing the square with vertices (0,0),(0,1),(1,1),(1,0)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.ReferenceTetrahedron","page":"Home","title":"WavePropBase.Geometry.ReferenceTetrahedron","text":"struct ReferenceTetrahedron\n\nSingleton type representing the tetrahedron with vertices (0,0,0),(0,0,1),(0,1,0),(1,0,0)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Geometry.ReferenceTriangle","page":"Home","title":"WavePropBase.Geometry.ReferenceTriangle","text":"struct ReferenceTriangle\n\nSingleton type representing the triangle with vertices (0,0),(0,1),(1,0)\n\n\n\n\n\n","category":"type"},{"location":"#Base.:==-Tuple{WavePropBase.Geometry.AbstractEntity, WavePropBase.Geometry.AbstractEntity}","page":"Home","title":"Base.:==","text":"==(Œ©1::AbstractEntity,Œ©2::AbstractEntity)\n\nTwo entities are considered equal geometric_dimension(Œ©1)==geometric_dimension(Œ©2) and abs(tag(Œ©1))=abs(tag(Œ©2)). For entities of co-dimension one, the sign of tag(Œ©) is used to determine the orientation of the normal vector.\n\nNotice that this implies dim and tag of an elementary entity should uniquely define it (up to the sign of tag), and therefore global variables like TAGS are needed to make sure newly created AbstractEntity have a new (dim,tag) identifier.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{WavePropBase.Geometry.Domain, WavePropBase.Geometry.Domain}","page":"Home","title":"Base.:==","text":"===(Œ©1::Domain,Œ©2::Domain)\n\nTwo Domains are equal if all their entities are equal (regardless of order).\n\n\n\n\n\n","category":"method"},{"location":"#Base.in-Tuple{WavePropBase.Geometry.ElementaryEntity, WavePropBase.Geometry.Domain}","page":"Home","title":"Base.in","text":"in(œâ::ElementaryEntity,Œ©::Domain)\n\nCheck whether an ElementaryEntity belongs to a Domain by recursively checking whether it belongs to its boundary.\n\n\n\n\n\n","category":"method"},{"location":"#Base.iterate","page":"Home","title":"Base.iterate","text":"iterate(Œ©::Domain)\n\nIterating over a domain means iterating over its entities.\n\n\n\n\n\n","category":"function"},{"location":"#Base.keys-Tuple{WavePropBase.Geometry.Domain, Integer}","page":"Home","title":"Base.keys","text":"Return all tags of the elementary entities in the domain Œ© corresponding to the dimension d.\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Union{Tuple{T}, Tuple{WavePropBase.Geometry.Domain, Vector{T}}} where T<:Integer","page":"Home","title":"Base.keys","text":"Return all tags of the elementary entities in the domain Œ© corresponding to the dimensions contained in dims.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{WavePropBase.Geometry.Domain}","page":"Home","title":"Base.length","text":"length(Œ©:::Domain)\n\nThe length of a domain corresponds to the number of elementary entities that make it.\n\n\n\n\n\n","category":"method"},{"location":"#Base.split-Tuple{WavePropBase.Geometry.AbstractHyperRectangle, Any, Any}","page":"Home","title":"Base.split","text":"split(rec::AbstractHyperRectangle,[axis]::Int,[place])\n\nSplit a hyperrectangle in two along the axis direction at the  position place. Returns a tuple with the two resulting hyperrectangles.\n\nWhen no place is given, defaults to splitting in the middle of the axis.\n\nWhen no axis and no place is given, defaults to splitting along the largest axis.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry._binary_split!-Tuple{WavePropBase.Geometry.ClusterTree, Any, Any}","page":"Home","title":"WavePropBase.Geometry._binary_split!","text":"_binary_split!(cluster::ClusterTree,dir,pos;parentcluster=cluster)\n_binary_split!(cluster::ClusterTree,f;parentcluster=cluster)\n\nSplit a ClusterTree into two, sorting all elements in the process. For each resulting child assign child.parent=parentcluster.\n\nPassing a dir and pos arguments splits the bounding_box box of node along direction dir at position pos, then sorts all points into the resulting  left/right nodes.\n\nIf passed a predicate f, each point is sorted according to whether f(x) returns true (point sorted on the left node) or false (point sorted on the right node). At the end a minimal HyperRectangle containing all left/right points is created.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.assertequaldim-Tuple{WavePropBase.Geometry.Domain, WavePropBase.Geometry.Domain}","page":"Home","title":"WavePropBase.Geometry.assertequaldim","text":"assertequaldim(Œ©1::Domain,Œ©2::Domain)\n\nCheck that two domains have same dimension.\n\nIf one of the domain (or both) are empty, the assertion is assumed to be true.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.clear_entities!-Tuple{}","page":"Home","title":"WavePropBase.Geometry.clear_entities!","text":"clear_entities!()\n\nEmpty the global variables used to keep track of the various entities created.\n\nSee also: ENTITIES, TAGS\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.external_boundary-Tuple{WavePropBase.Geometry.Domain}","page":"Home","title":"WavePropBase.Geometry.external_boundary","text":"Return the external boundaries inside a domain.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.internal_boundary-Tuple{WavePropBase.Geometry.Domain}","page":"Home","title":"WavePropBase.Geometry.internal_boundary","text":"Return the internal boundaries inside a domain.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.key-Tuple{WavePropBase.Geometry.AbstractEntity}","page":"Home","title":"WavePropBase.Geometry.key","text":"key(e::AbstractEntity)\n\nThe (dim,tag) pair used as a key to identify various abstract entities.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.new_tag-Tuple{Any}","page":"Home","title":"WavePropBase.Geometry.new_tag","text":"new_tag(dim)\n\nGenerate a unique tag for an AbstractEntity of dimension dim.\n\nThe implementation consists of adding one to the maximum value of TAGS[dim]\n\nSee also: TAGS.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.should_split-Tuple{Any, Any}","page":"Home","title":"WavePropBase.Geometry.should_split","text":"should_split(clt::ClusterTree,splitter::AbstractSplitter)\n\nDetermine whether or not a ClusterTree should be further divided.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.skeleton-Tuple{WavePropBase.Geometry.Domain}","page":"Home","title":"WavePropBase.Geometry.skeleton","text":"skeleton(Œ©::Domain)\n\nReturn all the boundaries of the domain, i.e. the domain's skeleton.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Geometry.split!-Tuple{Any, Any}","page":"Home","title":"WavePropBase.Geometry.split!","text":"split!(clt::ClusterTree,splitter::AbstractSplitter)\n\nDivide clt using the strategy implemented by splitter.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.boundary-Tuple{WavePropBase.Geometry.Domain}","page":"Home","title":"WavePropBase.boundary","text":"boundary(Œ©)\n\nReturn a domain comprising the external boundary of Œ©.\n\nSee also: external_boundary\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.distance-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, T} where T, WavePropBase.Geometry.AbstractHyperRectangle{N, T} where T}} where N","page":"Home","title":"WavePropBase.distance","text":"distance(x::SVector,r::HyperRectangle)\n\nThe (minimal) Euclidean distance between the point x and any point y ‚àà r.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.distance-Union{Tuple{N}, Tuple{WavePropBase.Geometry.AbstractHyperRectangle{N, T} where T, WavePropBase.Geometry.AbstractHyperRectangle{N, T} where T}} where N","page":"Home","title":"WavePropBase.distance","text":"distance(r1::AbstractHyperRectangle,r2::AbstractHyperRectangle)\n\nThe (minimal) Euclidean distance between a point x ‚àà r1 and y ‚àà r2.\n\n\n\n\n\n","category":"method"},{"location":"#Interpolation-module","page":"Home","title":"Interpolation module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase.Interpolation]","category":"page"},{"location":"#WavePropBase.Interpolation.AbstractElement","page":"Home","title":"WavePropBase.Interpolation.AbstractElement","text":"abstract type AbstractElement{D,T}\n\nFixed interpolation schemes over the domain D<:AbstractReferenceShape. This means that the basis functions used for the interpolation are knonw from the type. The type parameter T determines the return_type of the interpolant.\n\nInstances el of AbstractElement are expected to implement:\n\nel(xÃÇ): evaluate the interpolation scheme at the coordinate xÃÇ ‚àà D.\njacobian(el,xÃÇ) : evaluate the jacobian matrix of the interpolation at the   coordinate x ‚àà D.\n\nnote: Note\nFor performance reasons, both el(xÃÇ) and jacobian(el,xÃÇ) should take as input a StaticVector and output a static vector or array.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.AbstractPolynomialSpace","page":"Home","title":"WavePropBase.Interpolation.AbstractPolynomialSpace","text":"abstract type AbstractPolynomialSpace{D}\n\nA polynomial space over D. This is a vector space under polynomial addition and scalar multiplication.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.LagrangeElement","page":"Home","title":"WavePropBase.Interpolation.LagrangeElement","text":"struct LagrangeElement{D,Np,T} <: AbstractElement{D,T}\n\nStandard element over D <: AbstractReferenceShape commonly used in finite element methods. The underlying polynomial space is Pk{D,K}, and it evaluates to vals::SVector{Np,T} on the reference_nodes of the element.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.LagrangeLine","page":"Home","title":"WavePropBase.Interpolation.LagrangeLine","text":"const LagrangeLine = LagrangeElement{ReferenceLine}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.LagrangePoint","page":"Home","title":"WavePropBase.Interpolation.LagrangePoint","text":"const LagrangePoint = LagrangeElement{ReferencePoint}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.LagrangeSquare","page":"Home","title":"WavePropBase.Interpolation.LagrangeSquare","text":"const LagrangeSquare = LagrangeElement{ReferenceSquare}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.LagrangeTetrahedron","page":"Home","title":"WavePropBase.Interpolation.LagrangeTetrahedron","text":"const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.LagrangeTriangle","page":"Home","title":"WavePropBase.Interpolation.LagrangeTriangle","text":"const LagrangeTriangle = LagrangeElement{ReferenceTriangle}\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.Pk","page":"Home","title":"WavePropBase.Interpolation.Pk","text":"struct Pk{D,K} <: AbstractPolynomialSpace{D}\n\nThe space of all polynomials over D of degree ‚â§K.\n\nWhen D is a hypercube in d dimensions, the precise definition is Pk{D,K} = span{ùê±·∂ø : max(Œ∏)‚â§ K}; when D is a d-dimensional simplex, the space is Pk{D,K} = span{ùê±·∂ø : sum(Œ∏)‚â§ K}, where Œ∏ ‚àà ùêç·µà is a multi-index.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.Point","page":"Home","title":"WavePropBase.Interpolation.Point","text":"const Point = LagrangePoint\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.TensorLagInterp","page":"Home","title":"WavePropBase.Interpolation.TensorLagInterp","text":"struct TensorLagInterp{N,Td,T}\n\nGeneric Lagrange interpolation over an N-dimensional tensor grid. The implementation uses a multidimensional generalization of the barycentric formula.\n\nThe main constructor takes an SVector{N,Vector{Td}} containig the N one-dimensional nodes and an Array{N,T} of the function vals at the tensor product grid formed by the one-dimensional nodes.\n\nExamples:\n\nnx = 10\nny = 12\nx   = [0.5+0.5cos((2k-1)*œÄ/2nx) for k in 1:nx] # Chebyshev nodes\ny   = [0.5+0.5cos((2k-1)*œÄ/2ny) for k in 1:ny] # Chebyshev nodes\nf   = (x) -> cos(x[1]*x[2])\nvals = [f((x,y)) for x in x, y in y]\np   = TensorLagInterp(SVector(x,y),vals)\np((0.1,0.2)) ‚âà f((0.1,0.2))\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Interpolation.cheb1nodes-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any, Any}} where N","page":"Home","title":"WavePropBase.Interpolation.cheb1nodes","text":"cheb1nodes(n,a,b)\n\nReturn the n Chebyshev points of the first kind on the interval [a,b].\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Interpolation.cheb2nodes-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any, Any}} where N","page":"Home","title":"WavePropBase.Interpolation.cheb2nodes","text":"cheb2nodes(n,a,b)\n\nReturn the n Chebyshev points of the second kind on the interval [a,b]. The nodes are nested in the following sense: cheb2nodes(n,a,b) == cheb2nodes(2n-1,a,b)[1:2:end].\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Interpolation.degree-Union{Tuple{Union{Type{WavePropBase.Interpolation.LagrangeElement{D, Np, T} where T}, WavePropBase.Interpolation.LagrangeElement{D, Np, T} where T}}, Tuple{Np}, Tuple{D}} where {D, Np}","page":"Home","title":"WavePropBase.Interpolation.degree","text":"degree(el::LagrangeElement)\n\nThe polynomial degree of the element. A LagrangeElement of degree K and domain D belongs to the space Pk{D,K}.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Interpolation.lagrange_basis-Tuple{Any, WavePropBase.Interpolation.AbstractPolynomialSpace}","page":"Home","title":"WavePropBase.Interpolation.lagrange_basis","text":"lagrange_basis(nodes,[sp::AbstractPolynomialSpace])\n\nReturn the set of n polynomials in sp taking the value of 1 on node i and 0 on nodes j ‚âÇÃ∏ i for 1 ‚â§ i ‚â§ n. For N-dimensional tensor-product nodes represented in the form of an SVector{N,Vector{T}}, the argument sp may be ommited.\n\ndanger: Danger\nIt is assumed that the value of a function on nodes uniquely determine a polynomial in sp.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Interpolation.monomial_basis","page":"Home","title":"WavePropBase.Interpolation.monomial_basis","text":"monomial_basis(sp::Pk)\n\nReturn an NTuple containing a basis of monomials ùê±·∂ø spanning the polynomial space Pk.\n\n\n\n\n\n","category":"function"},{"location":"#Integration-module","page":"Home","title":"Integration module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase.Integration]","category":"page"},{"location":"#WavePropBase.Integration","page":"Home","title":"WavePropBase.Integration","text":"module Integration\n\nMethods for integrating over instances of AbstractReferenceShape.\n\nBesides some standard quadrature rules used in the FEM module, also defines singular integration routines useful for (weakly) singular integrands.\n\n\n\n\n\n","category":"module"},{"location":"#WavePropBase.Integration.AbstractQuadratureRule","page":"Home","title":"WavePropBase.Integration.AbstractQuadratureRule","text":"abstract type AbstractQuadratureRule{D<:AbstractReferenceShape}\n\nA quadrature rule for integrating a function over the domain D.\n\nAn instance q of AbstractQuadratureRule{D} is expected to implement the following methods:\n\nq() : return the nodes x and weights w of the quadrature rule on the reference domain D. For performance reasons, the result should depend only on the type of q.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.AbstractQuadratureRule-Tuple{}","page":"Home","title":"WavePropBase.Integration.AbstractQuadratureRule","text":"(q::AbstractQuadratureRule)()\n\nReturn the quadrature nodes x and weights w on the domain(q).\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Integration.AbstractSingularityHandler","page":"Home","title":"WavePropBase.Integration.AbstractSingularityHandler","text":"abstract type AbstractSingularityHandler{R}\n\nUsed for handling localized integrand singularities in R.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.Duffy","page":"Home","title":"WavePropBase.Integration.Duffy","text":"struct Duffy <: AbstractSingularityHandler{RefereceTriangle}\n\nChange of variables mapping the ReferenceSquare to the RefereceTriangle with the property that the jacobian vanishes at the (1,0) vertex of the triangle.\n\nUseful for integrating functions with a singularity on the (1,0) edge of the reference triangle.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.Fejer","page":"Home","title":"WavePropBase.Integration.Fejer","text":"struct Fejer{N}\n\nN-point Fejer's first quadrature rule for integrating a function over [0,1]. Exactly integrates all polynomials of degree ‚â§ N-1.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.Gauss","page":"Home","title":"WavePropBase.Integration.Gauss","text":"struct Gauss{D,N} <: AbstractQuadratureRule{D}\n\nTabulated N-point symmetric Gauss quadrature rule for integration over D.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.GaussLegendre","page":"Home","title":"WavePropBase.Integration.GaussLegendre","text":"struct GaussLegendre{N}\n\nN-point Gauss-Legendre quadrature rule for integrating a function over [0,1]. Exactly integrates all polynomials of degree ‚â§ 2N-1.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.GaussLegendre-Tuple{}","page":"Home","title":"WavePropBase.Integration.GaussLegendre","text":"GaussLegendre(;order)\n\nConstruct a GaussLegendre of the desired order over the [0,1] interval.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Integration.IMT","page":"Home","title":"WavePropBase.Integration.IMT","text":"struct IMT{A,P} <: AbstractSingularityHandler{ReferenceLine}\n\nOne-dimensional change of variables mapping [0,1] -> [0,1] with the property that all derivatives vanish at the point x=0.\n\nSee Davis and Rabinowitz.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.Kress","page":"Home","title":"WavePropBase.Integration.Kress","text":"struct Kress{P} <: AbstractSingularityHandler{ReferenceLine}\n\nChange of variables mapping [0,1] to [0,1] with the property that the first P-1 derivatives of the transformation vanish at x=0.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.KressP","page":"Home","title":"WavePropBase.Integration.KressP","text":"struct KressP{P} <: AbstractSingularityHandler{ReferenceLine}\n\nLike Kress, this change of variables maps the interval [0,1] onto itself, but the first P derivatives of the transformation vanish at both endpoints.\n\nThis change of variables can be used to periodize integrals in the following sense. Suppose we wish to compute the integral of f(x) from 0 to 1 where f is not a1-periodic function. If œï is an object of type KressP, then using it as a change of variables in the integration yields a similar integral from 0 to 1 (the interval 0‚â§0‚â§1 is mappend onto itself), but with integrand given by g(x) = f(œï(x))œï'(x). Since œï' vanishes (together with P of its derivatives), the function g(x) is now periodic (up to derivatives of order up to P) at the endpoints. Thus quadrature rules designed for periodic functions like the TrapezoidalP can be used to obtain high order convergence of g, which in turn yields a modified quadrature rule when viewed as a quadrature rule for f.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.SingularQuadratureRule","page":"Home","title":"WavePropBase.Integration.SingularQuadratureRule","text":"SingularQuadratureRule{D,Q,S} <: AbstractQuadratureRule{D}\n\nA quadrature rule over D intended to integrate functions which are singular at a known point s ‚àà D.\n\nA singular quadrature is rule is composed of a regular quadrature rule (e.g. GaussLegendre) and a AbstractSingularityHandler to transform the regular quadrature. The regular quadrature rule generates nodes and weights on the domain(sing_handler), and those are mapped into an appropriate quadrature over D = range(sing_handler) using the singularity handler.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.TensorProductQuadrature","page":"Home","title":"WavePropBase.Integration.TensorProductQuadrature","text":"TensorProductQuadrature{Q}\n\nA tensor-product of one-dimension quadrature rules. Integrates over [0,1]^d, where d=length(quad).\n\nExamples\n\nqx = Fejer(10)\nqy = GaussLegendre(15)\nq  = TensorProductQuadrature(qx,qy)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.TensorProductSingularityHandler","page":"Home","title":"WavePropBase.Integration.TensorProductSingularityHandler","text":"struct TensorProductSingularityHandler{S} <: AbstractSingularityHandler{ReferenceSquare}\n\nA tensor product of two one-dimensional AbstractSingularityHandlers for performing integration over the ReferenceSquare.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.Trapezoidal","page":"Home","title":"WavePropBase.Integration.Trapezoidal","text":"struct Trapezoidal{N} <: AbstractQuadratureRule{ReferenceLine}\n\nN-point trapezoidal rule for integrating a function over the interval [0,1].\n\nFor periodic functions over [0,1], see TrapezoidalP.\n\nExamples:\n\nq    = Trapezoidal(10)\nf(x) = exp(x)*cos(x)\nintegrate(f,q)\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration.TrapezoidalP","page":"Home","title":"WavePropBase.Integration.TrapezoidalP","text":"struct TrapezoidalP{N} <: AbstractQuadratureRule{ReferenceLine}\n\nOpen trapezoidal rule. Useful for periodic functions since it does not duplicate the boundary nodes, void duplication.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Integration._get_gauss_qnodes_and_qweights-Union{Tuple{D}, Tuple{Type{var\"#s3\"} where var\"#s3\"<:WavePropBase.Geometry.AbstractReferenceShape{D}, Any}} where D","page":"Home","title":"WavePropBase.Integration._get_gauss_qnodes_and_qweights","text":"_get_qnodes_and_qweights(R::Type{<:AbstractReferenceShape{D}}, N) where D\n\nReturns the N-point symmetric gaussian qnodes and qweights (x, w) for integration over R.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Integration.integrate-Tuple{Any, WavePropBase.Integration.AbstractQuadratureRule}","page":"Home","title":"WavePropBase.Integration.integrate","text":"integrate(f,q::AbstractQuadrature)\nintegrate(f,x,w)\n\nIntegrate the function f using the quadrature rule q. This is simply sum(f.(x) .* w), where x and w are the quadrature nodes and weights, respectively.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Integration.qnodes-Tuple{WavePropBase.Integration.AbstractQuadratureRule}","page":"Home","title":"WavePropBase.Integration.qnodes","text":"qnodes(Y)\n\nReturn the quadrature nodes associated with Y.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Integration.qrule_for_reference_shape-Tuple{Any, Any}","page":"Home","title":"WavePropBase.Integration.qrule_for_reference_shape","text":"qrule_for_reference_shape(ref,order)\n\nGiven a reference shape and a desired quadrature order, return an appropiate quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Integration.qweights-Tuple{WavePropBase.Integration.AbstractQuadratureRule}","page":"Home","title":"WavePropBase.Integration.qweights","text":"qweights(Y)\n\nReturn the quadrature weights associated with Y.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Integration.refine-Union{Tuple{WavePropBase.Integration.GaussLegendre{N}}, Tuple{N}, Tuple{WavePropBase.Integration.GaussLegendre{N}, Any}} where N","page":"Home","title":"WavePropBase.Integration.refine","text":"refine(q::AbstractQuadratureRule,[k=2])\n\nGenerate a similar quadrature rule, but with k-times as many quadrature nodes.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Integration.singular_quadrature-Tuple{Any, WavePropBase.Integration.SingularQuadratureRule, Any}","page":"Home","title":"WavePropBase.Integration.singular_quadrature","text":"singular_quadrature(k,q::SingularQuadratureRule,s)\n\nReturn nodes and weights to integrate a function over domain(q) with a factored weight k.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Integration.singular_weights-Tuple{Any, Any, WavePropBase.Integration.SingularQuadratureRule, Any}","page":"Home","title":"WavePropBase.Integration.singular_weights","text":"singular_weights(k,xi,q::SingularQuadratureRule,s)\n\n\n\n\n\n","category":"method"},{"location":"#Mesh-module","page":"Home","title":"Mesh module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase.Mesh]","category":"page"},{"location":"#WavePropBase.Mesh.AbstractMesh","page":"Home","title":"WavePropBase.Mesh.AbstractMesh","text":"abstract type AbstractMesh{N,T}\n\nAn abstract mesh structure in dimension N with primite data of type T (e.g. Float64 for double precision representation).\n\nConcrete subtypes of AbstractMesh should implement ElementIterator for accessing the mesh elements, and/or NodeIterator for accesing the mesh nodes.\n\nSee also: GenericMesh, UniformCartesianMesh\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Mesh.ElementIterator","page":"Home","title":"WavePropBase.Mesh.ElementIterator","text":"struct ElementIterator{E,M}\n\nReturn an iterator for all elements of type E on a mesh of type M.\n\nBesides the methods listed in the iterator iterface of Julia, some functions also require the getindex(iter,i::Int) method for accessing the i-th element directly.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Mesh.GenericMesh","page":"Home","title":"WavePropBase.Mesh.GenericMesh","text":"struct GenericMesh{N,T} <: AbstractMesh{N,T}\n\nData structure representing a generic mesh in an ambient space of dimension N, with data of type T.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Mesh.NodeIterator","page":"Home","title":"WavePropBase.Mesh.NodeIterator","text":"struct NodeIterator{M}\n\nIterator for all the nodes in a mesh of type M.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Mesh.SubMesh","page":"Home","title":"WavePropBase.Mesh.SubMesh","text":"struct SubMesh{N,T} <: AbstractMesh{N,T}\n\nCreate a view of a parent mesh over a given domain.\n\nA submesh implements the interface for AbstractMesh; therefore you can iterate over elements of the submesh just like you would with a mesh.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Mesh.UniformCartesianMesh","page":"Home","title":"WavePropBase.Mesh.UniformCartesianMesh","text":"struct UniformCartesianMesh{N,T} <: AbstractMesh{N,T}\n\nAn N-dimensional cartesian grid given as the tensor-product of N one-dimensional LinRange{T} grids.\n\nIterating over a UniformCartesianMesh generates the elements which compose the mesh; i.e. the HyperRectangle cells.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.Mesh.UniformCartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{WavePropBase.Geometry.HyperRectangle{N, T}, Tuple{Vararg{T, N}} where T}} where {N, T}","page":"Home","title":"WavePropBase.Mesh.UniformCartesianMesh","text":"UniformCartesianMesh(;domain::HyperRectangle,sz::NTuple)\n\nConstruct a uniform UniformCartesianMesh with sz[d] elements along dimension d.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Mesh.decompose-Tuple{WavePropBase.Geometry.ReferenceLine, Float64}","page":"Home","title":"WavePropBase.Mesh.decompose","text":"decompose(s::AbstractReferenceShape,x,[target_shape])\n\nDecompose an AbstractReferenceShape into LagrangeElements so that x is a vertex of the children elements.\n\nExamples\n\ns = ReferenceLine() el1, el2 = decompose(s,0.3) el1(1) == el2(0) == 0.3 # true\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Mesh.dom2elt-Tuple{WavePropBase.Mesh.GenericMesh, Any, DataType}","page":"Home","title":"WavePropBase.Mesh.dom2elt","text":"dom2elt(m::GenericMesh,Œ©,E)\n\nCompute the element indices idxs of the elements of type E composing Œ©, so that m[E][idxs] gives all the elements of type E meshing Œ©.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Mesh.dom2elt-Tuple{WavePropBase.Mesh.GenericMesh, Any}","page":"Home","title":"WavePropBase.Mesh.dom2elt","text":"dom2elt(m::GenericMesh,Œ©)\n\nReturn a Dict with keys being the element types of m, and values being the indices of the elements in Œ© of that type.\n\n\n\n\n\n","category":"method"},{"location":"#WavePropBase.Mesh.dom2elt-Tuple{WavePropBase.Mesh.SubMesh}","page":"Home","title":"WavePropBase.Mesh.dom2elt","text":"dom2elt(m::SubMesh,[E])\n\nA dictionary with keys being the element types of m, and values being the element indices in the parent mesh. If a type E is given, return the values associated with that key.\n\n\n\n\n\n","category":"method"},{"location":"#IO-module","page":"Home","title":"IO module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [WavePropBase.IO]","category":"page"},{"location":"#WavePropBase.IO.PlotPoints","page":"Home","title":"WavePropBase.IO.PlotPoints","text":"struct PlotPoints\n\nStructure used for dispatching SVector to plot recipes without type-piracy.\n\n\n\n\n\n","category":"type"},{"location":"#WavePropBase.IO.PlotTree","page":"Home","title":"WavePropBase.IO.PlotTree","text":"struct PlotTree\n\nUsed to plot entire tree associated with a tree node, instead of just the node.\n\n\n\n\n\n","category":"type"}]
}

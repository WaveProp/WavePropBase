var documenterSearchIndex = {"docs":
[{"location":"trees/#trees-section","page":"Trees","title":"Trees","text":"","category":"section"},{"location":"trees/","page":"Trees","title":"Trees","text":"CurrentModule = WavePropBase","category":"page"},{"location":"trees/#Overview","page":"Trees","title":"Overview","text":"","category":"section"},{"location":"trees/","page":"Trees","title":"Trees","text":"The Trees module is a short module defining the interface for dealing with tree-like data structures. It relies on AbstractTrees.jl for various utilities related to traversing trees and tree iterators.","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"The module defines the concrete type ClusterTree which can be used to partition elements of geometrical nature into a hierarchical structure according to an AbstractSplitter. This structure is currently used by the HMatrices.jl and IFGF.jl.","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"Tree-like data structures should inherit from AbstractTree, and are expected to implement the children and parent methods. Currently, one concrete implementation of AbstracTree is provided by WavePropBase: the ClusterTree.","category":"page"},{"location":"trees/#ClusterTree","page":"Trees","title":"ClusterTree","text":"","category":"section"},{"location":"trees/","page":"Trees","title":"Trees","text":"A ClusterTree{T,S,D} is a parametric type used to hierarchically cluster elements of type T into container of type S. Additionally, each node of the tree has a data field of type D (defaults to Nothing) that can be used to store additional node-specific information. The  elements contained in a given node can be retrieved using elements(node), which returns an iterable collection of elements of type T. ","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"To construct a ClusterTree, you must pass the elements and an AbstractSplitter implementing the desired splitting strategy and stopping criterion: concrete subtypes of AbstractSplitter should implement the should_split(clt,spl::AbstractSplitter) and split!(clt,splt::AbstractSplitter) methods. Refer to the documentation of each concrete subtype of AbstractSplitter (you can type subtypes(AbstractSplitter) to see what they are) for more information about the available splitting strategies and parameters.","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"An example of how to construct a ClusterTree is shown below:","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"using WavePropBase\npts = rand(WavePropBase.Point2D,100)\nsplitter = WavePropBase.CardinalitySplitter(nmax=5)\nclt = WavePropBase.ClusterTree(pts,splitter)","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"clt now represents the root of the tree. To visualize clt as a node, you can simply call plot(clt). More interestingly, if you want to plot e.g. the leaves of clt, you can do:","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"using Plots\nplotlyjs() # hide\nplot(WavePropBase.PlotTree(),clt;predicate=WavePropBase.isleaf)\nsavefig(\"clt1.png\")","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"(Image: cluster tree)","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"Changing the clustering strategy is as simple as:","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"splitter = WavePropBase.DyadicSplitter(nmax=5)\nclt = WavePropBase.ClusterTree(pts,splitter)\nplot(WavePropBase.PlotTree(),clt)\nsavefig(\"clt2.png\")","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"(Image: cluster tree)","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"In the example above the elements were simply points, which were sorted into container of HyperRectangle type according to their coordinates. You can sort elements of other types as long as they implement the center method; for instance, you may build a ClusterTree of triangle elements as long as you extend the method center from WavePropBase to work with your custom triangle type.","category":"page"},{"location":"trees/","page":"Trees","title":"Trees","text":"Finally, when calling ClusterTree(els,splitter), the elements in els are permuted internally so each node of the tree stores a contiguous subset of els. To avoid mutating els, and internal copy is made is stored in the ClusterTree object. Passing the keyword argument copy_elements=false will skip the deepcopy, and mutate instead the els argument passed. The permutation of els performed during the tree construction can be recovered using loc2glob.","category":"page"},{"location":"integration/#integration-section","page":"Integration","title":"Integration module","text":"","category":"section"},{"location":"integration/","page":"Integration","title":"Integration","text":"CurrentModule = WavePropBase","category":"page"},{"location":"integration/#Overview","page":"Integration","title":"Overview","text":"","category":"section"},{"location":"integration/","page":"Integration","title":"Integration","text":"The Integration module provides various quadrature rules and routines for integrating functions defined over AbstractReferenceShapes. Quadrature rules are expected to inherit from the AbstractQuadratureRule{D}, which describes a set of nodes and weights used to integrate a function over a reference domain D<:AbstractReferenceShape. Subtypes of AbstractQuadratureRule should implement at least (::AbstractQuadratureRule)() returning the nodes and weights.","category":"page"},{"location":"integration/","page":"Integration","title":"Integration","text":"The Integration module defines various quadrature rules such as ...","category":"page"},{"location":"integration/#Regular-integration-rules","page":"Integration","title":"Regular integration rules","text":"","category":"section"},{"location":"integration/","page":"Integration","title":"Integration","text":"TODO","category":"page"},{"location":"integration/#Singular-integration","page":"Integration","title":"Singular integration","text":"","category":"section"},{"location":"integration/","page":"Integration","title":"Integration","text":"TODO","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Modules = [ WavePropBase ]","category":"page"},{"location":"references/#WavePropBase.ENTITIES","page":"References","title":"WavePropBase.ENTITIES","text":"const ENTITIES\n\nGlobal dictionary storing the used entity tags (the value) for a given dimension (the key).\n\n\n\n\n\n","category":"constant"},{"location":"references/#WavePropBase.SType","page":"References","title":"WavePropBase.SType","text":"const SType{T} = Union{T,Type{T}}\n\nUnion type of T and its data type Type{T}. Used to simplify methods defined on singleton types where both foo(::T) and foo(::Type{T}) are required.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.TAGS","page":"References","title":"WavePropBase.TAGS","text":"const TAGS::Dict{Int,Vector{Int}}\n\nGlobal dictionary storing the used entity tags (the value) for a given dimension (the key).\n\n\n\n\n\n","category":"constant"},{"location":"references/#WavePropBase.etype_to_vtk_cell_type","page":"References","title":"WavePropBase.etype_to_vtk_cell_type","text":"const etype_to_vtk_cell_type\n\nDictionary mapping internal element types to a tuple containing:     - the corresponding WriteVTK cell types (following the convention     chosen by VTK, see below);     - the indices in the elements column that defines the element.     This is because we want to support the export of more than just the flat     elements available in the VTK specification, hence which may require     a conversion of some sort.\n\nSee VTK specification [Fig. 2] on http://www.vtk.org/VTK/img/file-formats.pdf\n\nVTK_VERTEX (=1)\nVTKPOLYVERTEX (=2)\nVTK_LINE (=3)\nVTKPOLYLINE (=4)\nVTK_TRIANGLE (=5)\nVTKTRIANGLESTRIP (=6)\nVTK_POLYGON (=7)\nVTK_PIXEL (=8)\nVTK_QUAD (=9)\nVTK_TETRA (=10)\nVTK_VOXEL (=11)\nVTK_HEXAHEDRON (=12)\nVTK_WEDGE (=13)\nVTK_PYRAMID (=14)\n\n\n\n\n\n","category":"constant"},{"location":"references/#WavePropBase.AbstractElement","page":"References","title":"WavePropBase.AbstractElement","text":"abstract type AbstractElement{D,T}\n\nElements given by a fixed interpolation schemes mapping points on the the domain D<:AbstractReferenceShape (of singleton type) to a value of type T.\n\nInstances el of AbstractElement are expected to implement:\n\nel(x̂): evaluate the interpolation scheme at the (reference) coordinate x̂ ∈ D.\njacobian(el,x̂) : evaluate the jacobian matrix of the interpolation at the (reference) coordinate x ∈ D.\n\nnote: Note\nFor performance reasons, both el(x̂) and jacobian(el,x̂) should take as input a StaticVector and output a static vector or static array.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.AbstractEntity","page":"References","title":"WavePropBase.AbstractEntity","text":"abstract type AbstractEntity\n\nEntity of geometrical nature. Identifiable throught its (dim,tag) key.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.AbstractHyperRectangle","page":"References","title":"WavePropBase.AbstractHyperRectangle","text":"abstract type AbstractHyperRectangle{N,T} <: AbstractElement{ReferenceHyperCube{N},SVector{N,T}}\n\nAxis-aligned hyperrectangle in N dimensions with coordinates of type SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.AbstractMesh","page":"References","title":"WavePropBase.AbstractMesh","text":"abstract type AbstractMesh{N,T}\n\nAn abstract mesh structure in dimension N with primite data of type T (e.g. Float64 for double precision representation).\n\nConcrete subtypes of AbstractMesh should implement ElementIterator for accessing the mesh elements, and/or NodeIterator for accesing the mesh nodes.\n\nSee also: GenericMesh, UniformCartesianMesh\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.AbstractPolynomialSpace","page":"References","title":"WavePropBase.AbstractPolynomialSpace","text":"abstract type AbstractPolynomialSpace{D}\n\nA polynomial space over D. This is a vector space under polynomial addition and scalar multiplication.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.AbstractQuadratureRule","page":"References","title":"WavePropBase.AbstractQuadratureRule","text":"abstract type AbstractQuadratureRule{D<:AbstractReferenceShape}\n\nA quadrature rule for integrating a function over the domain D.\n\nAn instance q of AbstractQuadratureRule{D} is expected to implement the following methods:\n\nq() : return the nodes x and weights w of the quadrature rule on the reference domain D. For performance reasons, the result should depend only on the type of q.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.AbstractQuadratureRule-Tuple{}","page":"References","title":"WavePropBase.AbstractQuadratureRule","text":"(q::AbstractQuadratureRule)()\n\nReturn the quadrature nodes x and weights w on the domain(q).\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.AbstractReferenceShape","page":"References","title":"WavePropBase.AbstractReferenceShape","text":"abstract type AbstractReferenceShape{N}\n\nA reference domain/shape in ℜᴺ.\n\nUsed mostly for defining more complex shapes as transformations mapping an AbstractReferenceShape into some region of ℜᴹ.\n\nSee e.g. ReferenceLine or ReferenceTriangle for some examples of concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.AbstractSingularityHandler","page":"References","title":"WavePropBase.AbstractSingularityHandler","text":"abstract type AbstractSingularityHandler{R}\n\nUsed for handling localized integrand singularities in R.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.AbstractSplitter","page":"References","title":"WavePropBase.AbstractSplitter","text":"abstract type AbstractSplitter\n\nAn AbstractSplitter is used to split a ClusterTree. The interface requires the following methods:\n\nshould_split(clt,splitter) : return a Bool determining if the ClusterTree should be further divided\nsplit!(clt,splitter) : perform the splitting of the ClusterTree handling the necessary data sorting.\n\nSee GeometricSplitter for an example of an implementation.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.AbstractTree","page":"References","title":"WavePropBase.AbstractTree","text":"abstract type AbstracTree end\n\nSupertype for tree-like objects.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.CardinalitySplitter","page":"References","title":"WavePropBase.CardinalitySplitter","text":"struct CardinalitySplitter <: AbstractSplitter\n\nUsed to split a ClusterTree along the largest dimension if length(tree)>nmax. The split is performed so the data is evenly distributed amongst all children.\n\nSee also: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ClusterTree","page":"References","title":"WavePropBase.ClusterTree","text":"mutable struct ClusterTree{T,S,D}\n\nTree structure used to cluster elements of type V = eltype(T) into containers of type S. The method center(::V)::SVector is required for the clustering algorithms. An additional data field of type D can be associated with each node to store node-specific information (it defaults to D=Nothing).\n\nFields:\n\n_elements::T : vector containing the sorted elements.\ncontainer::S : container for the elements in the current node.\nindex_range::UnitRange{Int} : indices of elements contained in the current node.\nloc2glob::Vector{Int} : permutation from the local indexing system to the original (global) indexing system used as input in the construction of the tree.\nchildren::Vector{ClusterTree{N,T,D}}\nparent::ClusterTree{N,T,D}\ndata::D : generic data field of type D.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ClusterTree-Union{Tuple{Any}, Tuple{D}, Tuple{Any, Any}} where D","page":"References","title":"WavePropBase.ClusterTree","text":"ClusterTree(elements,splitter;[copy_elements=true])\nClusterTree{D}(points,splitter;[copy_elements=true])\n\nConstruct a ClusterTree from the  given elements using the splitting strategy encoded in splitter. If copy_elements is set to false, the elements argument are directly stored in the ClusterTree and are permuted during the tree construction.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.ComplexPoint2D","page":"References","title":"WavePropBase.ComplexPoint2D","text":"const ComplexPoint2D\nconst ComplexPoint2D(x1, x2)\nconst ComplexPoint2D(x::NTuple{2, ComplexF64})\n\nA complex 2D point, stored in a StaticArray. ComplexPoint2D = SVector{2, ComplexF64}.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ComplexPoint3D","page":"References","title":"WavePropBase.ComplexPoint3D","text":"const ComplexPoint3D\nconst ComplexPoint3D(x1, x2, x3)\nconst ComplexPoint3D(x::NTuple{3, ComplexF64})\n\nA complex 3D point, stored in a StaticArray. ComplexPoint3D = SVector{3, ComplexF64}.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.CustomQuadratureRule","page":"References","title":"WavePropBase.CustomQuadratureRule","text":"struct CustomQuadratureRule{D<:AbstractReferenceShape,N,T<:SVector} <: AbstractQuadratureRule{D}\n\nN-point user-defined quadrature rule for integrating over D.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.Domain","page":"References","title":"WavePropBase.Domain","text":"struct Domain\n\nRepresent a physical domain as a union of entities.\n\nSee also: AbstractEntity, ElementaryEntity.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.Duffy","page":"References","title":"WavePropBase.Duffy","text":"struct Duffy <: AbstractSingularityHandler{RefereceTriangle}\n\nChange of variables mapping the ReferenceSquare to the RefereceTriangle with the property that the jacobian vanishes at the (1,0) vertex of the triangle.\n\nUseful for integrating functions with a singularity on the (1,0) edge of the reference triangle.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.DyadicMaxDepthSplitter","page":"References","title":"WavePropBase.DyadicMaxDepthSplitter","text":"struct DyadicMaxDepthSplitter <: AbstractSplitter\n\nSimilar to DyadicSplitter, but splits nodes until a maximum depth is reached.\n\nSee also: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.DyadicMinimalSplitter","page":"References","title":"WavePropBase.DyadicMinimalSplitter","text":"struct DyadicMinimalSplitter <: AbstractSplitter\n\nSimilar to DiadicSplitter, but the boundin boxes are shrank to the minimal axis-aligned boxes at the end.\n\nSee also: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.DyadicSplitter","page":"References","title":"WavePropBase.DyadicSplitter","text":"struct DyadicSplitter <: AbstractSplitter\n\nUsed to split an N dimensional ClusterTree into 2^N children until at most nmax points are contained in node.\n\nSee also: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ElementIterator","page":"References","title":"WavePropBase.ElementIterator","text":"struct ElementIterator{E,M}\n\nReturn an iterator for all elements of type E on a mesh of type M.\n\nBesides the methods listed in the iterator iterface of Julia, some functions also require the getindex(iter,i::Int) method for accessing the i-th element directly.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ElementaryEntity","page":"References","title":"WavePropBase.ElementaryEntity","text":"struct ElementaryEntity <: AbstractEntity\n\nThe most basic representation of an AbstractEntity.\n\nFields:\n\ndim::UInt8: the geometrical dimension of the entity (e.g. line has dim=1, surface has dim=2, etc)\ntag::Int64: an integer tag associated to the entity\nboundary::Vector{AbstractEntity}: the entities of dimension dim-1 forming the entity's boundary\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ElementaryEntity-Tuple{Any, Any}","page":"References","title":"WavePropBase.ElementaryEntity","text":"ElementaryEntity(dim,tag)\n\nConstruct an ElementaryEntity with an empty boundary .\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.Fejer","page":"References","title":"WavePropBase.Fejer","text":"struct Fejer{N}\n\nN-point Fejer's first quadrature rule for integrating a function over [0,1]. Exactly integrates all polynomials of degree ≤ N-1.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.Gauss","page":"References","title":"WavePropBase.Gauss","text":"struct Gauss{D,N} <: AbstractQuadratureRule{D}\n\nTabulated N-point symmetric Gauss quadrature rule for integration over D.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.GenericMesh","page":"References","title":"WavePropBase.GenericMesh","text":"struct GenericMesh{N,T} <: AbstractMesh{N,T}\n\nData structure representing a generic mesh in an ambient space of dimension N, with data of type T.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.GeometricMinimalSplitter","page":"References","title":"WavePropBase.GeometricMinimalSplitter","text":"struct GeometricMinimalSplitter <: AbstractSplitter\n\nLike GeometricSplitter, but shrinks the children's containters.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.GeometricSplitter","page":"References","title":"WavePropBase.GeometricSplitter","text":"struct GeometricSplitter <: AbstractSplitter\n\nUsed to split a ClusterTree in half along the largest axis.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.HyperCube","page":"References","title":"WavePropBase.HyperCube","text":"struct HyperCube{N,T}\n\nAxis-aligned hypercube in N dimensions given by low_corner::SVector{N,T} and side::T.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.HyperRectangle","page":"References","title":"WavePropBase.HyperRectangle","text":"struct HyperRectangle{N,T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.IMT","page":"References","title":"WavePropBase.IMT","text":"struct IMT{A,P} <: AbstractSingularityHandler{ReferenceLine}\n\nOne-dimensional change of variables mapping [0,1] -> [0,1] with the property that all derivatives vanish at the point x=0.\n\nSee Davis and Rabinowitz.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.Kress","page":"References","title":"WavePropBase.Kress","text":"struct Kress{P} <: AbstractSingularityHandler{ReferenceLine}\n\nChange of variables mapping [0,1] to [0,1] with the property that the first P-1 derivatives of the transformation vanish at x=0.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.KressP","page":"References","title":"WavePropBase.KressP","text":"struct KressP{P} <: AbstractSingularityHandler{ReferenceLine}\n\nLike Kress, this change of variables maps the interval [0,1] onto itself, but the first P derivatives of the transformation vanish at both endpoints.\n\nThis change of variables can be used to periodize integrals in the following sense. Suppose we wish to compute the integral of f(x) from 0 to 1 where f is not a1-periodic function. If ϕ is an object of type KressP, then using it as a change of variables in the integration yields a similar integral from 0 to 1 (the interval 0≤0≤1 is mappend onto itself), but with integrand given by g(x) = f(ϕ(x))ϕ'(x). Since ϕ' vanishes (together with P of its derivatives), the function g(x) is now periodic (up to derivatives of order up to P) at the endpoints. Thus quadrature rules designed for periodic functions like the TrapezoidalOpen can be used to obtain high order convergence of g, which in turn yields a modified quadrature rule when viewed as a quadrature rule for f.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.LagrangeElement","page":"References","title":"WavePropBase.LagrangeElement","text":"struct LagrangeElement{D,Np,T} <: AbstractElement{D,T}\n\nStandard element over D <: AbstractReferenceShape commonly used in finite element methods. The underlying polynomial space is PolynomialSpace{D,K}, and its interpolant maps the Np reference_nodes in D to Np values of type T stored in the field vals.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.LagrangeLine","page":"References","title":"WavePropBase.LagrangeLine","text":"const LagrangeLine = LagrangeElement{ReferenceLine}\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.LagrangePoint","page":"References","title":"WavePropBase.LagrangePoint","text":"const LagrangePoint{N,T} = LagrangeElement{ReferencePoint,1,SVector{N,T}}\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.LagrangeSquare","page":"References","title":"WavePropBase.LagrangeSquare","text":"const LagrangeSquare = LagrangeElement{ReferenceSquare}\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.LagrangeTetrahedron","page":"References","title":"WavePropBase.LagrangeTetrahedron","text":"const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.LagrangeTriangle","page":"References","title":"WavePropBase.LagrangeTriangle","text":"const LagrangeTriangle = LagrangeElement{ReferenceTriangle}\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.NodeIterator","page":"References","title":"WavePropBase.NodeIterator","text":"struct NodeIterator{M}\n\nIterator for all the nodes in a mesh of type M.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.PlotPoints","page":"References","title":"WavePropBase.PlotPoints","text":"struct PlotPoints\n\nStructure used for dispatching SVector to plot recipes without type-piracy.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.PlotTree","page":"References","title":"WavePropBase.PlotTree","text":"struct PlotTree\n\nUsed to plot entire tree associated with a tree node, instead of just the node.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.Point1D","page":"References","title":"WavePropBase.Point1D","text":"const Point1D\nconst Point1D(x1)\n\nA point in 1D space, stored in a StaticArray. Point1D = SVector{1, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.Point2D","page":"References","title":"WavePropBase.Point2D","text":"const Point2D\nconst Point2D(x1, x2)\nconst Point2D(x::NTuple{2, Float64})\n\nA point in 2D space, stored in a StaticArray. Point2D = SVector{2, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.Point3D","page":"References","title":"WavePropBase.Point3D","text":"const Point3D\nconst Point3D(x1, x2, x3)\nconst Point3D(x::NTuple{3, Float64})\n\nA point in 3D space, stored in a StaticArray. Point3D = SVector{3, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.PointEntity","page":"References","title":"WavePropBase.PointEntity","text":"PointEntity{N,T} <: AbstractEntity\n\nZero-dimension geometrical entity. As a subtype of [AbstractEntity],(@ref) the (dim,tag) of all created point entities get added to the global ENTITIES. Intended usage is to build higher dimensionsional entities, and not to represent regular points such as grid points.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.PolynomialSpace","page":"References","title":"WavePropBase.PolynomialSpace","text":"struct PolynomialSpace{D,K} <: AbstractPolynomialSpace{D}\n\nThe space of all polynomials of degree ≤K, commonly referred to as ℙₖ.\n\nThe type parameter D, of singleton type, is used to determine the reference domain of the polynomial basis. In particular, when D is a hypercube in d dimensions, the precise definition is ℙₖ = span{𝐱ᶿ : 0≤max(θ)≤ K}; when D is a d-dimensional simplex, the space is ℙₖ = span{𝐱ᶿ : 0≤sum(θ)≤ K}, where θ ∈ 𝐍ᵈ is a multi-index.\n\nSee also: monomial_basis, lagrange_basis\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.PrincipalComponentSplitter","page":"References","title":"WavePropBase.PrincipalComponentSplitter","text":"struct PrincipalComponentSplitter <: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.PseudoBlockMatrix","page":"References","title":"WavePropBase.PseudoBlockMatrix","text":"struct PseudoBlockMatrix{T<:SMatrix,S} <: AbstractMatrix{T}\n\nA struct which behaves identically to a Matrix{T}, but with the underlying data stored as a Matrix{S}, where S::Number = eltype(T). This allows for the use of blas routines under-the-hood, while providing a convenient interface for handling matrices over tensors.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ReferenceHyperCube","page":"References","title":"WavePropBase.ReferenceHyperCube","text":"struct ReferenceHyperCube{N}\n\nSingleton type representing the axis-aligned hypercube in N dimensions with the lower corner at the origin and the upper-corner at (1,1,…,1).\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ReferenceLine","page":"References","title":"WavePropBase.ReferenceLine","text":"struct ReferenceLine\n\nSingleton type representing the [0,1] segment.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ReferencePoint","page":"References","title":"WavePropBase.ReferencePoint","text":"struct ReferencePoint\n\nSingleton type representing a reference zero-dimensional entitty (i.e. a point).\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ReferenceSquare","page":"References","title":"WavePropBase.ReferenceSquare","text":"const ReferenceSquare = ReferenceHyperCube{2}\n\nSingleton type representing the square with vertices (0,0),(0,1),(1,1),(1,0)\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ReferenceTetrahedron","page":"References","title":"WavePropBase.ReferenceTetrahedron","text":"struct ReferenceTetrahedron\n\nSingleton type representing the tetrahedron with vertices (0,0,0),(0,0,1),(0,1,0),(1,0,0)\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.ReferenceTriangle","page":"References","title":"WavePropBase.ReferenceTriangle","text":"struct ReferenceTriangle\n\nSingleton type representing the triangle with vertices (0,0),(0,1),(1,0)\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.SingularQuadratureRule","page":"References","title":"WavePropBase.SingularQuadratureRule","text":"SingularQuadratureRule{D,Q,S} <: AbstractQuadratureRule{D}\n\nA quadrature rule over D intended to integrate functions which are singular at a known point s ∈ D.\n\nA singular quadrature is rule is composed of a regular quadrature rule (e.g. GaussLegendre) and a AbstractSingularityHandler to transform the regular quadrature. The regular quadrature rule generates nodes and weights on the domain(sing_handler), and those are mapped into an appropriate quadrature over D = range(sing_handler) using the singularity handler.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.SubMesh","page":"References","title":"WavePropBase.SubMesh","text":"struct SubMesh{N,T} <: AbstractMesh{N,T}\n\nCreate a view of a parent mesh over a given domain.\n\nA submesh implements the interface for AbstractMesh; therefore you can iterate over elements of the submesh just like you would with a mesh.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.TensorLagInterp","page":"References","title":"WavePropBase.TensorLagInterp","text":"struct TensorLagInterp{N,Td,T}\n\nGeneric Lagrange interpolation over an N-dimensional tensor grid. The implementation uses a multidimensional generalization of the barycentric formula.\n\nThe main constructor takes an SVector{N,Vector{Td}} containig the N one-dimensional nodes and an Array{N,T} of the function vals at the tensor product grid formed by the one-dimensional nodes.\n\nExamples:\n\nnx = 10\nny = 12\nx   = [0.5+0.5cos((2k-1)*π/2nx) for k in 1:nx] # Chebyshev nodes\ny   = [0.5+0.5cos((2k-1)*π/2ny) for k in 1:ny] # Chebyshev nodes\nf   = (x) -> cos(x[1]*x[2])\nvals = [f((x,y)) for x in x, y in y]\np   = TensorLagInterp(SVector(x,y),vals)\np((0.1,0.2)) ≈ f((0.1,0.2))\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.TensorProductQuadrature","page":"References","title":"WavePropBase.TensorProductQuadrature","text":"TensorProductQuadrature{Q}\n\nA tensor-product of one-dimension quadrature rules. Integrates over [0,1]^d, where d=length(quad).\n\nExamples\n\nqx = Fejer(10)\nqy = TrapezoidalOpen(15)\nq  = TensorProductQuadrature(qx,qy)\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.TensorProductSingularityHandler","page":"References","title":"WavePropBase.TensorProductSingularityHandler","text":"struct TensorProductSingularityHandler{S} <: AbstractSingularityHandler{ReferenceSquare}\n\nA tensor product of two one-dimensional AbstractSingularityHandlers for performing integration over the ReferenceSquare.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.Trapezoidal","page":"References","title":"WavePropBase.Trapezoidal","text":"struct Trapezoidal{N} <: AbstractQuadratureRule{ReferenceLine}\n\nClosed N-point trapezoidal rule for integrating a function over the interval [0,1].\n\nExamples:\n\nq    = Trapezoidal(10)\nf(x) = exp(x)*cos(x)\nintegrate(f,q)\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.TrapezoidalOpen","page":"References","title":"WavePropBase.TrapezoidalOpen","text":"struct TrapezoidalOpen{N} <: AbstractQuadratureRule{ReferenceLine}\n\nOpen trapezoidal rule.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.UniformCartesianMesh","page":"References","title":"WavePropBase.UniformCartesianMesh","text":"struct UniformCartesianMesh{N,T} <: AbstractMesh{N,T}\n\nAn N-dimensional cartesian grid given as the tensor-product of N one-dimensional LinRange{T} grids.\n\nIterating over a UniformCartesianMesh generates the elements which compose the mesh; i.e. the HyperRectangle cells.\n\n\n\n\n\n","category":"type"},{"location":"references/#WavePropBase.UniformCartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{WavePropBase.HyperRectangle{N, T}, Int64}} where {N, T}","page":"References","title":"WavePropBase.UniformCartesianMesh","text":"UniformCartesianMesh(domain::HyperRectangle,sz::NTuple)\nUniformCartesianMesh(domain::HyperRectangle;step::NTuple)\n\nConstruct a uniform UniformCartesianMesh with sz[d] elements along dimension d. If the kwarg step is passed, construct a UniformCartesianMesh with elements of approximate size step.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:==-Tuple{WavePropBase.AbstractEntity, WavePropBase.AbstractEntity}","page":"References","title":"Base.:==","text":"==(Ω1::AbstractEntity,Ω2::AbstractEntity)\n\nTwo entities are considered equal geometric_dimension(Ω1)==geometric_dimension(Ω2) and abs(tag(Ω1))=abs(tag(Ω2)). For entities of co-dimension one, the sign of tag(Ω) is used to determine the orientation of the normal vector.\n\nNotice that this implies dim and tag of an elementary entity should uniquely define it (up to the sign of tag), and therefore global variables like TAGS are needed to make sure newly created AbstractEntity have a new (dim,tag) identifier.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:==-Tuple{WavePropBase.Domain, WavePropBase.Domain}","page":"References","title":"Base.:==","text":"===(Ω1::Domain,Ω2::Domain)\n\nTwo Domains are equal if all their entities are equal (regardless of order).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.in-Tuple{WavePropBase.ElementaryEntity, WavePropBase.Domain}","page":"References","title":"Base.in","text":"in(ω::ElementaryEntity,Ω::Domain)\n\nCheck whether an ElementaryEntity belongs to a Domain by recursively checking whether it belongs to its boundary.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.iterate","page":"References","title":"Base.iterate","text":"iterate(Ω::Domain)\n\nIterating over a domain means iterating over its entities.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.keys-Tuple{WavePropBase.Domain, Integer}","page":"References","title":"Base.keys","text":"Return all tags of the elementary entities in the domain Ω corresponding to the dimension d.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.keys-Union{Tuple{T}, Tuple{WavePropBase.Domain, Vector{T}}} where T<:Integer","page":"References","title":"Base.keys","text":"Return all tags of the elementary entities in the domain Ω corresponding to the dimensions contained in dims.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.length-Tuple{WavePropBase.Domain}","page":"References","title":"Base.length","text":"length(Ω:::Domain)\n\nThe length of a domain corresponds to the number of elementary entities that make it.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.parent-Tuple{WavePropBase.AbstractTree}","page":"References","title":"Base.parent","text":"parent(t::AbstractTree)\n\nThe node's parent. If t is a root, then parent(t)==t.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.split-Tuple{WavePropBase.AbstractHyperRectangle, Any, Any}","page":"References","title":"Base.split","text":"split(rec::AbstractHyperRectangle,[axis]::Int,[place])\n\nSplit a hyperrectangle in two along the axis direction at the  position place. Returns a tuple with the two resulting hyperrectangles.\n\nWhen no place is given, defaults to splitting in the middle of the axis.\n\nWhen no axis and no place is given, defaults to splitting along the largest axis.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase._binary_split!-Tuple{WavePropBase.ClusterTree, Any, Any}","page":"References","title":"WavePropBase._binary_split!","text":"_binary_split!(cluster::ClusterTree,dir,pos;parentcluster=cluster)\n_binary_split!(cluster::ClusterTree,f;parentcluster=cluster)\n\nSplit a ClusterTree into two, sorting all elements in the process. For each resulting child assign child.parent=parentcluster.\n\nPassing a dir and pos arguments splits the container of node along direction dir at position pos, then sorts all points into the resulting  left/right nodes.\n\nIf passed a predicate f, each point is sorted according to whether f(x) returns true (point sorted on the left node) or false (point sorted on the right node). At the end a minimal HyperRectangle containing all left/right points is created.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase._get_gauss_qnodes_and_qweights-Union{Tuple{D}, Tuple{Type{<:WavePropBase.AbstractReferenceShape{D}}, Any}} where D","page":"References","title":"WavePropBase._get_gauss_qnodes_and_qweights","text":"_get_qnodes_and_qweights(R::Type{<:AbstractReferenceShape{D}}, N) where D\n\nReturns the N-point symmetric gaussian qnodes and qweights (x, w) for integration over R.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase._normal-Union{Tuple{StaticArrays.SMatrix{N, M}}, Tuple{M}, Tuple{N}} where {N, M}","page":"References","title":"WavePropBase._normal","text":"_normal(jac::SMatrix{M,N})\n\nGiven a an M by N matrix representing the jacobian of a codimension one object, compute the normal vector.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase._vtk_cells","page":"References","title":"WavePropBase._vtk_cells","text":"_vtk_cells(mesh::GenericMesh, E::DataType)\n_vtk_cells(mesh::GenericMesh, Ω::Domain)\n\nCreates the vector of all elements contained in the mesh in the format required by WriteVTK for a particular element type E<:AbstractElement or a Domain instance.\n\n\n\n\n\n","category":"function"},{"location":"references/#WavePropBase._vtk_points-Tuple{WavePropBase.GenericMesh}","page":"References","title":"WavePropBase._vtk_points","text":"_vtk_points(mesh::GenericMesh)\n\nCreates the matrix of nodes in the format required by WriteVTK.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.abstractmethod-Tuple{DataType}","page":"References","title":"WavePropBase.abstractmethod","text":"abstractmethod\n\nA method of an abstract type for which concrete subtypes are expected to provide an implementation.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.ambient_dimension-Union{Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:WavePropBase.AbstractReferenceShape{N}}, Tuple{N}} where N","page":"References","title":"WavePropBase.ambient_dimension","text":"ambient_dimension(x)\n\nDimension of the ambient space where x lives. For geometrical objects this can differ from its geometric_dimension; for example a triangle in ℝ³ has ambient dimension 3 but geometric dimension 2, while a curve in ℝ³ has ambient dimension 3 but geometric dimension 1.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.assert_extension","page":"References","title":"WavePropBase.assert_extension","text":"assert_extension(fname,ext,[msg])\n\nCheck that fname is of extension ext. Print the message msg as an assertion error otherwise.\n\n\n\n\n\n","category":"function"},{"location":"references/#WavePropBase.assertequaldim-Tuple{WavePropBase.Domain, WavePropBase.Domain}","page":"References","title":"WavePropBase.assertequaldim","text":"assertequaldim(Ω1::Domain,Ω2::Domain)\n\nCheck that two domains have same dimension.\n\nIf one of the domain (or both) are empty, the assertion is assumed to be true.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.blockmatrix_to_matrix-Union{Tuple{Matrix{B}}, Tuple{B}} where B<:(StaticArrays.SMatrix)","page":"References","title":"WavePropBase.blockmatrix_to_matrix","text":"blockmatrix_to_matrix(A::Matrix{B}) where {B<:SMatrix}\n\nConvert a Matrix{B}, where B<:SMatrix, to the equivalent Matrix{T}, where T = eltype(B)\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.blockvector_to_vector-Union{Tuple{Vector{B}}, Tuple{B}} where B<:(StaticArrays.SVector)","page":"References","title":"WavePropBase.blockvector_to_vector","text":"blockvector_to_vector(A::Vector{B}) where {B<:SVector}\n\nConvert a Vector{B}, where B<:SVector, to the equivalent Vector{T}, where T = eltype(B)\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.boundary-Tuple{WavePropBase.Domain}","page":"References","title":"WavePropBase.boundary","text":"boundary(Ω::Domain)\n\nReturn a domain comprising the external boundary of Ω.\n\nSee also: external_boundary\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.cart2pol-Tuple{Any, Any}","page":"References","title":"WavePropBase.cart2pol","text":"cart2pol(x,y)\n\nMap cartesian coordinates x,y to polar coordinates r,θ. The convention followed is that -π ≤ θ ≤ π.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.cart2sph-Tuple{Any, Any, Any}","page":"References","title":"WavePropBase.cart2sph","text":"cart2sph(x,y,z)\n\nMap cartesian coordinates x,y,z to spherical ones r, θ, φ representing the radius, elevation, and azimuthal angle respectively. The convention followed is that 0 ≤ θ ≤ π and -π < φ ≤ π.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.center-Tuple{WavePropBase.AbstractHyperRectangle}","page":"References","title":"WavePropBase.center","text":"center(Ω)\n\nCenter of the smallest ball containing Ω.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.cheb1nodes-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any, Any}} where N","page":"References","title":"WavePropBase.cheb1nodes","text":"cheb1nodes(n,a,b)\n\nReturn the n Chebyshev points of the first kind on the interval [a,b].\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.cheb2nodes-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any, Any}} where N","page":"References","title":"WavePropBase.cheb2nodes","text":"cheb2nodes(n,a,b)\n\nReturn the n Chebyshev points of the second kind on the interval [a,b]. The nodes are nested in the following sense: cheb2nodes(n,a,b) == cheb2nodes(2n-1,a,b)[1:2:end].\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.children-Tuple{WavePropBase.AbstractTree}","page":"References","title":"WavePropBase.children","text":"children(t::AbstractTree)\n\nIterable collection of the node's children.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.clear_entities!-Tuple{}","page":"References","title":"WavePropBase.clear_entities!","text":"clear_entities!()\n\nEmpty the global variables used to keep track of the various entities created.\n\nSee also: ENTITIES, TAGS\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.container-Tuple{WavePropBase.ClusterTree}","page":"References","title":"WavePropBase.container","text":"container(clt::ClusterTree)\n\nReturn the object enclosing all the elements of the clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.container_type-Union{Tuple{WavePropBase.ClusterTree{T, S}}, Tuple{S}, Tuple{T}} where {T, S}","page":"References","title":"WavePropBase.container_type","text":"container_type(clt::ClusterTree)\n\nType used to enclose the elements of clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.coords-Tuple{Tuple}","page":"References","title":"WavePropBase.coords","text":"coords(x)\n\nReturn an SVector with the cartesian coordinates associated to a geometrical object x.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.cross_product_matrix-Tuple{Any}","page":"References","title":"WavePropBase.cross_product_matrix","text":"cross_product_matrix(v)\n\nReturns the matrix Aᵥ associated with the cross product v × ϕ so that v × ϕ = Aᵥϕ.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.decompose-Tuple{WavePropBase.ReferenceLine, Float64}","page":"References","title":"WavePropBase.decompose","text":"decompose(s::AbstractReferenceShape,x,[target_shape])\n\nDecompose an AbstractReferenceShape into LagrangeElements so that x is a vertex of the children elements.\n\nExamples\n\ns = ReferenceLine() el1, el2 = decompose(s,0.3) el1(1) == el2(0) == 0.3 # true\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.decrement_index","page":"References","title":"WavePropBase.decrement_index","text":"decrement_index(I::CartesianIndex,k[,n=1])\n\nEquivalent to increment_index(I,k,-n)\n\n\n\n\n\n","category":"function"},{"location":"references/#WavePropBase.degree-Union{Tuple{Union{Type{WavePropBase.LagrangeElement{D, Np}}, WavePropBase.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}","page":"References","title":"WavePropBase.degree","text":"degree(el::LagrangeElement)\n\nThe polynomial degree of the element. A LagrangeElement of degree K and domain D belongs to the space PolynomialSpace{D,K}.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.depth","page":"References","title":"WavePropBase.depth","text":"depth(tree::AbstractTree,acc=0)\n\nRecursive function to compute the depth of node in a a tree-like structure.\n\nOverload this function if your structure has a more efficient way to compute depth (e.g. if it stores it in a field).\n\n\n\n\n\n","category":"function"},{"location":"references/#WavePropBase.diagonalblockmatrix_to_matrix-Union{Tuple{AbstractVector{B}}, Tuple{B}} where B<:(StaticArrays.SMatrix)","page":"References","title":"WavePropBase.diagonalblockmatrix_to_matrix","text":"diagonalblockmatrix_to_matrix(A::Matrix{B}) where {B<:SMatrix}\n\nConvert a diagonal block matrix A::AbstractVector{B}, where A is the list of diagonal blocks and B<:SMatrix, to the equivalent SparseMatrixCSC{T}, where T = eltype(B).\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.diameter-Tuple{WavePropBase.AbstractHyperRectangle}","page":"References","title":"WavePropBase.diameter","text":"diameter(Ω)\n\nLargest distance between x and y for x,y ∈ Ω.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.dimension-Union{Tuple{Union{Type{WavePropBase.PolynomialSpace{D, K}}, WavePropBase.PolynomialSpace{D, K}}}, Tuple{K}, Tuple{D}} where {D, K}","page":"References","title":"WavePropBase.dimension","text":"dimension(space)\n\nThe length of a basis for space; i.e. the number of linearly independent elements required to span space.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.distance-Tuple{WavePropBase.ClusterTree, WavePropBase.ClusterTree}","page":"References","title":"WavePropBase.distance","text":"distance(X::ClusterTree, Y::ClusterTree)\n\nDistance between the containers of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.distance-Union{Tuple{N}, Tuple{StaticArrays.SVector{N}, WavePropBase.AbstractHyperRectangle{N}}} where N","page":"References","title":"WavePropBase.distance","text":"distance(x::SVector,r::HyperRectangle)\n\nThe (minimal) Euclidean distance between the point x and any point y ∈ r.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.distance-Union{Tuple{N}, Tuple{WavePropBase.AbstractHyperRectangle{N}, WavePropBase.AbstractHyperRectangle{N}}} where N","page":"References","title":"WavePropBase.distance","text":"distance(Ω₁,Ω₂)\n\nMinimal Euclidean distance between a point x ∈ Ω₁ and y ∈ Ω₂.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.dom2elt-Tuple{WavePropBase.GenericMesh, Any, DataType}","page":"References","title":"WavePropBase.dom2elt","text":"dom2elt(m::GenericMesh,Ω,E)\n\nCompute the element indices idxs of the elements of type E composing Ω, so that m[E][idxs] gives all the elements of type E meshing Ω.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.dom2elt-Tuple{WavePropBase.GenericMesh, Any}","page":"References","title":"WavePropBase.dom2elt","text":"dom2elt(m::GenericMesh,Ω)\n\nReturn a Dict with keys being the element types of m, and values being the indices of the elements in Ω of that type.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.dom2elt-Tuple{WavePropBase.SubMesh}","page":"References","title":"WavePropBase.dom2elt","text":"dom2elt(m::SubMesh,[E])\n\nA dictionary with keys being the element types of m, and values being the element indices in the parent mesh. If a type E is given, return the values associated with that key.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.domain-Union{Tuple{WavePropBase.AbstractQuadratureRule{D}}, Tuple{D}} where D","page":"References","title":"WavePropBase.domain","text":"domain(f)\n\nGiven a function-like object f: Ω → R, return Ω.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.element_type-Union{Tuple{WavePropBase.ClusterTree{T}}, Tuple{T}} where T","page":"References","title":"WavePropBase.element_type","text":"element_type(clt::ClusterTree)\n\nType of elements sorted in clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.elements-Tuple{WavePropBase.ClusterTree}","page":"References","title":"WavePropBase.elements","text":"elements(clt::ClusterTree)\n\nIterable list of the elements inside clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.enable_debug-Tuple{}","page":"References","title":"WavePropBase.enable_debug","text":"enable_debug(mname)\n\nActivate debugging messages.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.entities-Tuple{WavePropBase.Domain}","page":"References","title":"WavePropBase.entities","text":"entities(Ω::Domain)\n\nReturn a vector of all elementary entities making up a domain.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.external_boundary-Tuple{WavePropBase.Domain}","page":"References","title":"WavePropBase.external_boundary","text":"Return the external boundaries inside a domain.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.filter_tree","page":"References","title":"WavePropBase.filter_tree","text":"filter_tree(f,tree,isterminal=true)\n\nReturn a vector containing all the nodes of tree such that filter(node)==true.  The argument isterminal can be used to control whether to continue the search on children of nodes for which f(node)==true.\n\n\n\n\n\n","category":"function"},{"location":"references/#WavePropBase.filter_tree!","page":"References","title":"WavePropBase.filter_tree!","text":"filter_tree!(filter,nodes,tree,[isterminal=true])\n\nLike filter_tree, but appends results to nodes.\n\n\n\n\n\n","category":"function"},{"location":"references/#WavePropBase.geometric_dimension-Tuple{WavePropBase.AbstractEntity}","page":"References","title":"WavePropBase.geometric_dimension","text":"geometric_dimension(x::AbstractEntity)\ngeometric_dimension(Ω::Domain)\n\nNumber of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in ℝ² or in ℝ³), while surfaces have geometric dimension of 2.\n\nWhen the argument is a Domain, return the largest geometric dimension encoutered.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.global_add_entity!-Tuple{WavePropBase.AbstractEntity}","page":"References","title":"WavePropBase.global_add_entity!","text":"global_add_entity!(ent::AbstractEntity)\n\nAdd ent to the global dictionary ENTITIES and update TAGS with its (dim,tag) key. This function should be called by the inner constructor of every AbstractEntity; see the constructor of ElementaryEntity for an example.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.image-Tuple{WavePropBase.IMT}","page":"References","title":"WavePropBase.image","text":"image(f)\n\nThe a function-like object f: Ω → R, return R.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.increment_index","page":"References","title":"WavePropBase.increment_index","text":"increment_index(I::CartesianIndex,k[,n=1])\n\nIncrement I by n along  the dimension k. This is equivalent to I += n*eₖ, where eₖ is a vector with with 1 at the  k-th coordinate and zeros elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"references/#WavePropBase.index_range-Tuple{WavePropBase.ClusterTree}","page":"References","title":"WavePropBase.index_range","text":"index_range(clt::ClusterTree)\n\nIndices of elements in root_elements(clt) which lie inside clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.integrate-Tuple{Any, WavePropBase.AbstractQuadratureRule}","page":"References","title":"WavePropBase.integrate","text":"integrate(f,q::AbstractQuadrature)\nintegrate(f,x,w)\n\nIntegrate the function f using the quadrature rule q. This is simply sum(f.(x) .* w), where x and w are the quadrature nodes and weights, respectively.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.internal_boundary-Tuple{WavePropBase.Domain}","page":"References","title":"WavePropBase.internal_boundary","text":"Return the internal boundaries inside a domain.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.isleaf-Tuple{WavePropBase.AbstractTree}","page":"References","title":"WavePropBase.isleaf","text":"isleaf(t)\n\nReturn true if t has no children.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.isroot-Tuple{Any}","page":"References","title":"WavePropBase.isroot","text":"isroot(t)\n\nReturn true if t is its own parent.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.jacobian-Tuple{Any, Any}","page":"References","title":"WavePropBase.jacobian","text":"jacobian(f,x)\n\nGiven a (possibly vector-valued) function f : 𝐑ᵐ → 𝐅ᵐ, return the m × n matrix Aᵢⱼ = ∂fᵢ/∂xⱼ.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.key-Tuple{WavePropBase.AbstractEntity}","page":"References","title":"WavePropBase.key","text":"key(e::AbstractEntity)\n\nThe (dim,tag) pair used as a key to identify geometrical entities.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.lagrange_basis-Tuple{Any, WavePropBase.AbstractPolynomialSpace}","page":"References","title":"WavePropBase.lagrange_basis","text":"lagrange_basis(nodes,[sp::AbstractPolynomialSpace])\n\nReturn the set of n polynomials in sp taking the value of 1 on node i and 0 on nodes j ≂̸ i for 1 ≤ i ≤ n. For N-dimensional tensor-product nodes represented in the form of an SVector{N,Vector{T}}, the argument sp may be ommited.\n\ndanger: Danger\nIt is assumed that the value of a function on nodes uniquely determine a polynomial in sp.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.loc2glob-Tuple{WavePropBase.ClusterTree}","page":"References","title":"WavePropBase.loc2glob","text":"loc2glob(clt::ClusterTree)\n\nThe permutation from the (local) indexing system of the elements of the clt to the (global) indexes used upon the construction of the tree.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.matrix_to_blockmatrix-Tuple{Matrix, Type{<:StaticArrays.SMatrix}}","page":"References","title":"WavePropBase.matrix_to_blockmatrix","text":"matrix_to_blockmatrix(A::Matrix,B)\n\nConvert a Matrix{T} to a Matrix{B}, where B<:Type{SMatrix}. The element type of B must match that of A, and the size of A must be divisible by the size of B along each dimension.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.monomial_basis","page":"References","title":"WavePropBase.monomial_basis","text":"monomial_basis(sp::PolynomialSpace)\n\nReturn an NTuple containing a basis of monomials 𝐱ᶿ spanning the polynomial space PolynomialSpace.\n\n\n\n\n\n","category":"function"},{"location":"references/#WavePropBase.new_tag-Tuple{Integer}","page":"References","title":"WavePropBase.new_tag","text":"new_tag(dim)\n\nGenerate a unique tag for an AbstractEntity of dimension dim.\n\nThe implementation consists of adding one to the maximum value of TAGS[dim]\n\nSee also: TAGS.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.normal-Tuple{WavePropBase.AbstractElement, Any}","page":"References","title":"WavePropBase.normal","text":"normal(el,x̂)\n\nThe unit normal vector at coordinate x̂, guaranteed to be orthogonal to all columns of jacobian(el,x).\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.notimplemented-Tuple{}","page":"References","title":"WavePropBase.notimplemented","text":"notimplemented()\n\nThings which should probably be implemented at some point.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.partition_by_depth-Tuple{Any}","page":"References","title":"WavePropBase.partition_by_depth","text":"partition_by_depth(tree)\n\nGiven a tree, return a partition vector whose i-th entry stores all the nodes in tree with depth=i-1. Empty nodes are not added to the partition.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.partition_by_height-Tuple{Any}","page":"References","title":"WavePropBase.partition_by_height","text":"partition_by_height(tree)\n\nGiven a tree, return a partition vector whose i-th entry stores all the nodes in tree with height=i-1. The height of the tree is thus lenth(partition), with partition(end)==tree.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.pol2cart-Tuple{Any, Any}","page":"References","title":"WavePropBase.pol2cart","text":"pol2cart(r,θ)\n\nMap polar coordinates r,θ to cartesian coordinates x,y.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.print_threads_info-Tuple{}","page":"References","title":"WavePropBase.print_threads_info","text":"print_threads_info()\n\nPrints in console the total number of threads.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.qnodes-Tuple{WavePropBase.AbstractQuadratureRule}","page":"References","title":"WavePropBase.qnodes","text":"qnodes(Y)\n\nReturn the quadrature nodes associated with Y.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.qrule_for_reference_shape-Tuple{Any, Any}","page":"References","title":"WavePropBase.qrule_for_reference_shape","text":"qrule_for_reference_shape(ref,order)\n\nGiven a reference shape and a desired quadrature order, return an appropiate quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.qweights-Tuple{WavePropBase.AbstractQuadratureRule}","page":"References","title":"WavePropBase.qweights","text":"qweights(Y)\n\nReturn the quadrature weights associated with Y.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.radius-Tuple{WavePropBase.AbstractHyperRectangle}","page":"References","title":"WavePropBase.radius","text":"radius(Ω)\n\nHalf the diameter.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.reference_nodes-Tuple{Any}","page":"References","title":"WavePropBase.reference_nodes","text":"reference_nodes(el::LagrangeElement)\n\nReturn the reference nodes on domain(el) used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.\n\nWe use the same convention as gmsh for defining the reference nodes and their order (see node ordering on gmsh documentation).\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.return_type-Union{Tuple{WavePropBase.AbstractElement{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"References","title":"WavePropBase.return_type","text":"return_type(f)\n\nThe type returned by function-like objects.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.root_elements-Tuple{WavePropBase.ClusterTree}","page":"References","title":"WavePropBase.root_elements","text":"root_elements(clt::ClusterTree)\n\nThe elements contained in the root of the tree to which clt belongs.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.section-Union{Tuple{D}, Tuple{WavePropBase.HyperRectangle{D}, Integer}} where D","page":"References","title":"WavePropBase.section","text":"section(rec::HyperRectangle{D},ax)\n\nReturn the dimension D-1 HyperRectangle obtained by deleting the coordinates at the ax dimension.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.should_split-Tuple{Any, Any, WavePropBase.AbstractSplitter}","page":"References","title":"WavePropBase.should_split","text":"should_split(clt::ClusterTree, depth, splitter::AbstractSplitter)\n\nDetermine whether or not a ClusterTree should be further divided.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.singular_quadrature-Tuple{Any, WavePropBase.SingularQuadratureRule, Any}","page":"References","title":"WavePropBase.singular_quadrature","text":"singular_quadrature(k,q::SingularQuadratureRule,s)\n\nReturn nodes and weights to integrate a function over domain(q) with a factored weight k.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.singular_weights-Tuple{Any, Any, WavePropBase.SingularQuadratureRule, Any}","page":"References","title":"WavePropBase.singular_weights","text":"singular_weights(k,xi,q::SingularQuadratureRule,s)\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.skeleton-Tuple{WavePropBase.Domain}","page":"References","title":"WavePropBase.skeleton","text":"skeleton(Ω::Domain)\n\nReturn all the boundaries of the domain, i.e. the domain's skeleton.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.sort_by_type-Tuple{Any}","page":"References","title":"WavePropBase.sort_by_type","text":"sort_by_type(v)\n\nSort the elements of v into vectors vi according to their type. Return a Dict{DataType,Vector} mapping each type to a vector of that type.\n\nExamples\n\nv = [1,\"a\",3,\"b\"]\ndict = sort_by_type(v)\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.sph2cart-Tuple{Any, Any, Any}","page":"References","title":"WavePropBase.sph2cart","text":"sph2cart(x,y,z)\n\nMap spherical coordinates r,θ,φ representing the radius, elevation, and azimuthal angle respectively, to cartesian ones x, y, z .\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.split!-Tuple{Any, WavePropBase.AbstractSplitter}","page":"References","title":"WavePropBase.split!","text":"split!(clt::ClusterTree,splitter::AbstractSplitter)\n\nDivide clt using the strategy implemented by splitter. This function is reponsible of assigning the children and parent fields, as well as of permuting the data of clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.svector-Tuple{Any, Any}","page":"References","title":"WavePropBase.svector","text":"svector(f,n)\n\nJust like Base.ntuple, but convert output to an SVector.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.tag-Tuple{WavePropBase.AbstractEntity}","page":"References","title":"WavePropBase.tag","text":"tag(::AbstractEntity)\n\nInteger tag used to idetify geometrical entities.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.vector_to_blockvector-Tuple{Vector, Type{<:StaticArrays.SVector}}","page":"References","title":"WavePropBase.vector_to_blockvector","text":"vector_to_blockvector(A::Vector,B)\n\nConvert a Vector{T} to a Vector{B}, where B<:Type{SVector}. The element type of B must match that of A, and the size of A must be divisible by the size of B along each dimension.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.vtk_mesh_file-Tuple{WavePropBase.GenericMesh, String}","page":"References","title":"WavePropBase.vtk_mesh_file","text":"vtk_mesh_file(mesh::GenericMesh[, Ω::Domain], name::String)\n\nCreates a VTK file (.vtu) with name name containing the mesh information. It is possible to export only a Domain (i.e. only a part of the mesh).\n\nNote that all the heavy lifting is done by the package WriteVTK. We refer to its documentation for more information.\n\nWarning: the output is not an actual file (on disk). To save it, simply write:\n\nvtk_mesh_file(mesh, \"my_mesh\") |> vtk_save\n\nTo add some data (scalar or vector values at the mesh nodes or mesh cells) for visualization purposes, you can do for instance:\n\nvtkfile = vtk_mesh_file(mesh, name)\nvtkfile[\"my_point_data\", VTKPointData()] = pdata\nvtkfile[\"my_cell_data\", VTKCellData()] = cdata\nvtk_save(vtkfile)\n\nIt is possible also to export a partition Ωs::Vector{Domain} using Multiblock files (.vtm), for instance like so\n\nvtmfile = vtk_multiblock(name)\nfor (Ω, pdata) in zip(Ωs, pdatas)\n    vtkfile = vtk_mesh_file(mesh, Ω, name)\n    vtkfile[\"my_point_data\", VTKPointData()] = pdata\nend\nvtk_save(vtmfile)\n\nTo save a sequence of solutions (time steps, iterations), simply append the number of the element to the file name. Paraview will recognize the sequence automatically.\n\n\n\n\n\n","category":"method"},{"location":"references/#WavePropBase.@interface","page":"References","title":"WavePropBase.@interface","text":"@interface f [n=1]\n\nDeclare that the function f is an interface function. The call f(args...) resolves to M.f(args...) where M is parent module of the args[n] object.\n\nThe somewhat contrived example below illustrates how this can be used to have a generic method defined in module A applied to a type defined on module B which is independent of A but which implements the interface function f:\n\nmodule A\n    using WavePropBase: @interface\n    @interface foo\n    # a method which works on any type `x` implementing the `foo` function\n    do_work(x) = 2*foo(x)\nend\n\nmodule B\n    struct Foo end\n    foo(x::Foo) = 1\nend\n\nusing .A\nusing .B\nfoo = B.Foo()\nA.do_work(foo)\n\n# output\n\n2\n\nNote that if in the example above module A implements a generic version of foo, the call A.do_work(foo) would use that method instead based on the dispatch rules.\n\n\n\n\n\n","category":"macro"},{"location":"geometry/#geometry-section","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"CurrentModule = WavePropBase","category":"page"},{"location":"geometry/#Overview","page":"Geometry","title":"Overview","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"The Geometry module is of fundamental importance as it defines the interface expected from geometrical objects. Appropriately defining the geometry is one of the first stages in setting up a simulation, and it precedes the creation of a mesh. Recall that (at a high-level), the usual workflow is:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"    fboxGeometry rightarrow fboxMesh rightarrow fboxSolver rightarrow fboxSolution","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Geometry then handles everything related to the representation of geometrical entities and domains, as well as various operations on them. Furthermore, the Geometry module also defines various simple reference shapes (see. AbstractReferenceShape) which form the basis for interpolation and integration procedures on more complex surfaces.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"The most elementary object is an entity, which describes an atomic piece of curve/surface/volume. Entities can then be grouped together to form domains, and certain set operations can be performed on domains. Domains can later be discretized to generate a mesh where actual computations can be performed. In the following sections we will briefly describe the main structures of the Geometry module, as well as provide some examples of creating geometrical objects.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"note: Note\nThe Geometry module itself does not handle the actual representation of geometrical objects. Such functionality, which can be quite complex in practice, is delegated to other packages and/or software which implement the expected interface. Currently, ParametricSurfaces and GmshSDK provide two ways of actually creating geometrical objects, and some examples in this page will use them to illustrate the ideas.","category":"page"},{"location":"geometry/#Entities","page":"Geometry","title":"Entities","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Entities are the most basic geometrical objects. They can represent a point, curve, surface, or volume. All entities are expected to inherit from AbstractEntity, and should extend the key and the boundary methods. Calling key(ent::AbstractEntity) should return a (dim::Integer,tag::Integer) which uniquely identifies the entity. The dim value is simply its geometrical dimension: zero for points, one for curves, two for surfaces, and so on, while tag is an integer used to distinguish the entity from others.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Because the (dim,tag) key should be unique, the global variable TAGS exists to keep track of the existing tags, and all types which inherit from AbstractEntity should implement an inner constructor which calls global_add_entity! upon creation of a new object. This function will add the entity to the global dictionary ENTITIES so that it can always be retrieved by its (dim,tag) key, as well as update the TAGS variable with the new (dim,tag). When running code in the REPL, it is sometimes useful to call clear_entities!() to empty the TAGS and ENTITIES variables in order to avoid unnecessary cluttering.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"The Geometry module provides one (minimal) implementation of AbstractEntity: the ElementaryEntity type. This type is useful for geometrical objects for which no parametric information is available. For instance, when reading files from Gmsh, the Gmsh entities are imported as ElementaryEntitys containing a dim, tag, and boundary field, but no information on the entity's parametrization is explicitly available. ","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"tip: Tip\nThe entity concept is widely used in Gmsh to describe the elementary geometrical objects inside a model, and the ElementaryEntity structure closely mimics what you may recover from the Gmsh API.    ","category":"page"},{"location":"geometry/#Domains","page":"Geometry","title":"Domains","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"The Domain type provides a convenient way to groups several AbstractEntity in order to form more complex geometrical objects. Domains support various set operations such as unions, intersection, and set difference. Furthremore, domains can be used to index parts of a mesh, as described in the Mesh section.","category":"page"},{"location":"geometry/#Reference-shapes","page":"Geometry","title":"Reference shapes","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"The AbstractReferenceShape{N} type describes singleton types representing (fixed) geometrical shapes in N dimensions. Concrete subtypes include ReferenceLine, ReferenceTriangle, ReferenceSquare, and the ReferenceTetrahedron.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Various interpolation and integration routines can then be efficiently defined on these singleton types, and more complex interpolation/integration over more complex elements can be carried out by combining the routines on the reference element with a parametrization of the complex element.","category":"page"},{"location":"mesh/#mesh-section","page":"Meshes","title":"Mesh","text":"","category":"section"},{"location":"mesh/","page":"Meshes","title":"Meshes","text":"CurrentModule = WavePropBase","category":"page"},{"location":"mesh/#Overview","page":"Meshes","title":"Overview","text":"","category":"section"},{"location":"mesh/#Mesh-structures","page":"Meshes","title":"Mesh structures","text":"","category":"section"},{"location":"mesh/#GenericMesh","page":"Meshes","title":"GenericMesh","text":"","category":"section"},{"location":"mesh/#CartesianMesh","page":"Meshes","title":"CartesianMesh","text":"","category":"section"},{"location":"mesh/#SubMesh","page":"Meshes","title":"SubMesh","text":"","category":"section"},{"location":"mesh/","page":"Meshes","title":"Meshes","text":"using GmshSDK\n@gmsh begin    \n    tag1 = gmsh.model.occ.addSphere(0,0,0,1)\n    tag2 = gmsh.model.occ.addSphere(0,0,0,1)\n    gmsh.model.occ.synchronize()\n    #Ω    = GmshSDK.Domain()\n    #msh  = GmshSDK.meshgen(Ω)\nend","category":"page"},{"location":"interpolation/#interpolation-section","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"CurrentModule = WavePropBase","category":"page"},{"location":"interpolation/#Overview","page":"Interpolation","title":"Overview","text":"","category":"section"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"The Interpolation module defines an interface for talking about polynomial spaces and interpolation. The central concept of this module is that of an AbstractElement{D,T}, which maps points on a reference domain (of type <:AbstractReferenceShape) to values of type T. The AbstractElement interface expects the methods (el::AbstractElement)(u), which evaluates the underlying interpolant at the (reference) coordinate u, and jacobian(el,u), which computes the jacobian at the (reference) coordinate u.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"AbstractElements are commonly used to describe functions over AbstractReferenceShapes, and such functions can in turn be used to describe more complex geometrical shapes used e.g. in a mesh. By composing a function representation on a reference element with the representation of the element itself as a map from the reference element, we can therefore represent a function over a (possibly complex) geometrical element.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"The Interpolation module provides a few concrete implementations of AbstractElements which are described next, but other packages may use the interface by implementing the methods (::AbstractElement)(x) and jacobian(el,x) (see e.g. ParametricElement in the ParametricSurfaces package).","category":"page"},{"location":"interpolation/#LagrangeElements","page":"Interpolation","title":"LagrangeElements","text":"","category":"section"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"One of the simplest AbstractElements is the LagrangeElement{D,T,Np}, which defines a polynomial mapping the Np reference nodes on D to Np values of type T. The reference_nodes depend only on D and Np (and therefore on the type of the element). We use the same convention as Gmsh to define the order of the reference nodes on the various reference shapes; see node ordering on the Gmsh documentation for a more in-depth description. ","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"In WaveProp, LagrangeElements are often used to describe (possibly curved) mesh elements. The triangle with vertices (1,1),(2,2),(1.5,3) can for example be created using:","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"using WavePropBase, Plots\nplotlyjs() # hide\npts = (1,1),(2,2),(1.5,3)\nel  = WavePropBase.LagrangeTriangle(pts)\nplot(el)\nsavefig(\"el1.png\")","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"(Image: triangular element)","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"Note that, as per the AbstractElement interface, you may evaluate the parametrization and the jacobian at any point on the reference element (not just the reference nodes):","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"u = WavePropBase.Point2D(0.25,0.25)\n@show el(u), WavePropBase.jacobian(el,u)","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"If the triangle is instead in three dimensions, it suffices to pass three-dimensional points:","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"pts = (1,1,0),(2,2,1),(1.5,3,1)\nel  = WavePropBase.LagrangeTriangle(pts)\nplot(el)\nsavefig(\"el2.png\")","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"(Image: triangular element)","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"Very similar constructs can be used to work higher order (curved) triangles, or with other LagrangeElements such as LagrangeSquare or LagrangeTetrahedron; see their docstrings for more details.","category":"page"},{"location":"#WavePropBase","page":"WavePropBase","title":"WavePropBase","text":"","category":"section"},{"location":"","page":"WavePropBase","title":"WavePropBase","text":"CurrentModule = WavePropBase","category":"page"},{"location":"#Overview","page":"WavePropBase","title":"Overview","text":"","category":"section"},{"location":"","page":"WavePropBase","title":"WavePropBase","text":"This package provides some basic functionality used across the WaveProp organization. It defines a common set of methods and structures to talk about things like domains, meshes, trees, quadratures, etc. It is essentially a factorization of code that was being duplicated across different packages. Unless you are developing a package, there is little reason for you to depend directly on WavePropBase.","category":"page"},{"location":"#Package-structure","page":"WavePropBase","title":"Package structure","text":"","category":"section"},{"location":"","page":"WavePropBase","title":"WavePropBase","text":"The package consists of a single module, and has no exported structures. The code has been physically organized into the following subfolders:","category":"page"},{"location":"","page":"WavePropBase","title":"WavePropBase","text":"Utils\nGeometry\nTrees\nInterpolation\nIntegration\nMesh\nIO","category":"page"},{"location":"#Index","page":"WavePropBase","title":"Index","text":"","category":"section"},{"location":"","page":"WavePropBase","title":"WavePropBase","text":"Modules = [WavePropBase]","category":"page"},{"location":"io/#io-section","page":"IO","title":"IO module","text":"","category":"section"},{"location":"io/","page":"IO","title":"IO","text":"CurrentModule = WavePropBase","category":"page"},{"location":"io/#Overview","page":"IO","title":"Overview","text":"","category":"section"},{"location":"io/","page":"IO","title":"IO","text":"The IO module provides various recipes for Plots.jl, as well functionality to export meshes and solutions to .vtk format using WriteVTK. Note that the vtkIO.jl file is only loaded if WriteVTK is available (i.e. you must type using WriteVTK for the file to be loaded).","category":"page"},{"location":"utils/#utils-section","page":"Utils","title":"Utils module","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"CurrentModule = WavePropBase","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"The Utils module provides a place to define auxiliary/convenience functions and structures that do not naturally fit into the other modules. ","category":"page"}]
}
